# 第16章:帖子投票功能深度解析

> **本章导读**
>
> 帖子可以发布和浏览了,但用户如何表达对内容的认可?投票(Vote)功能是社区平台的灵魂机制!Reddit、知乎、掘金都靠投票来实现内容质量筛选。
>
> 本章将深入讲解投票系统的设计思想、业务规则、参数校验,为下一章的Redis实现打好基础。

---

## 📚 本章目标

学完本章,你将掌握:

1. 理解投票系统的业务价值和设计目标
2. 掌握Reddit投票算法的核心思想
3. 设计合理的投票业务规则
4. 实现投票参数的定义和校验
5. 理解投票状态机的转换逻辑
6. 学习oneof校验标签的使用
7. 掌握投票分数的计算方法

---

## 1. 为什么需要投票功能?

### 1.1 投票的业务价值

**传统论坛的问题:**
```
按时间排序:
[最新] 标题党垃圾内容    ← 排在最上面
[1小时前] 优质深度文章   ← 淹没在底部
[2小时前] 垃圾广告
```

**问题:**
- 新发的垃圾内容占据首页
- 优质旧内容无法被发现
- 内容质量无法体现
- 用户体验差

---

**有了投票系统:**
```
按热度排序:
[热度: 8520] 优质深度文章 (+1000赞)  ← 高质量内容置顶
[热度: 3200] 有趣的讨论 (+500赞)
[热度: -100] 标题党垃圾 (-50踩)     ← 低质量内容沉底
```

**好处:**
- 📊 **内容筛选**: 让优质内容脱颖而出
- 👍 **用户参与**: 增强用户互动和归属感
- 🔥 **热度计算**: 结合时间和投票实现智能排序
- 🚫 **垃圾过滤**: 差内容自动沉底

---

### 1.2 投票系统的设计目标

**核心原则:**
1. **公平性**: 不能无限投票,不能重复投票
2. **时效性**: 新内容有机会展示,旧内容逐渐衰减
3. **防刷性**: 防止恶意刷票,设置时间窗口限制
4. **可追溯**: 记录用户投票历史,支持改票

**关键问题:**
- ❓ 一个用户能投几票? → **1票**(赞成/反对/取消)
- ❓ 能否改票? → **可以**(从赞成改为反对)
- ❓ 旧帖子能投票吗? → **不能**(超过一周禁止投票)
- ❓ 如何计算热度? → **投票数 + 时间衰减**

---

## 2. Reddit投票算法详解

### 2.1 Reddit热度排序的灵感

Reddit是全球最大的社区平台之一,它的投票算法非常经典:

**公式:**
```
热度分数 = (赞成票 - 反对票) / (发布时间)^重力系数
```

**核心思想:**
1. **投票差值**: 赞成票多的内容分数高
2. **时间衰减**: 时间越久,分数越低
3. **平衡新旧**: 新内容自带"时间加成"

---

### 2.2 简化版算法: 分数 = 发布时间 + 投票加成

**Bluebell的实现:**
```
帖子分数 = 发布时间戳 + (赞成票 - 反对票) * 432
```

**参数说明:**

| 参数 | 值 | 含义 |
|------|-----|------|
| 发布时间戳 | Unix时间戳 | 新帖子天然有时间优势 |
| 赞成票 | 用户点赞数 | 每个赞 +432分 |
| 反对票 | 用户点踩数 | 每个踩 -432分 |
| **432 = 86400秒/天 ÷ 200票** | 一天的秒数除以200 | 含义:**200张赞成票可以让帖子"续命"一天** |

---

### 2.3 为什么是432?

**推导过程:**
```
目标: 帖子需要多少票才能在热榜上"抵消"一天的时间衰减?

1天 = 86400秒
假设: 200张赞成票 = 1天的时间优势

每票分数 = 86400 ÷ 200 = 432分/票
```

**实际效果:**
```
帖子A: 发布于2025-01-01 00:00:00, 0票
  分数 = 1735689600 + 0*432 = 1735689600

帖子B: 发布于2024-12-31 00:00:00, 200票 (早一天)
  分数 = 1735603200 + 200*432 = 1735603200 + 86400 = 1735689600

→ 两个帖子分数相同! 200票成功"抵消"了一天的时间差!
```

---

### 2.4 投票算法示例

**场景1: 新帖子 vs 旧帖子**
```
帖子A: 发布于今天, 10票
  分数 = 1735776000 + 10*432 = 1735780320

帖子B: 发布于昨天, 5票
  分数 = 1735689600 + 5*432 = 1735691760

→ 新帖子 A 分数更高, 排在前面
```

---

**场景2: 高票旧帖 vs 低票新帖**
```
帖子A: 发布于3天前, 500票 (优质内容)
  分数 = 1735603200 + 500*432 = 1735819200

帖子B: 发布于今天, 0票
  分数 = 1735776000 + 0*432 = 1735776000

→ 高票旧帖 A 仍然排在前面! (500票 > 2.4天的时间差)
```

---

## 3. 投票业务规则设计

### 3.1 核心规则

**规则1: 一人一票**
- 每个用户对每个帖子只能投1票
- 可以投赞成(+1)或反对(-1)
- 可以取消投票(0)

**规则2: 允许改票**
```
初始: 未投票 (0)
↓
投赞成 (+1) → 分数 +432
↓
改为反对 (-1) → 分数 -432*2 = -864 (差值为2)
↓
取消投票 (0) → 分数 +432
```

**规则3: 时间窗口限制**
- 发布后**7天内**可以投票
- 超过7天禁止投票(防止刷旧帖)

**规则4: 禁止重复投票**
- 如果用户当前是赞成(+1),再次点赞成会报错
- 必须先取消投票,或者改为反对

---

### 3.2 投票状态机

```
        ┌─────────────┐
        │  未投票 (0) │ ← 初始状态
        └─────────────┘
             ↓ ↑
     投赞成 ┌─┘ └─┐ 取消
           ↓       ↑
    ┌──────────────┐
    │  赞成 (+1)   │
    └──────────────┘
           ↓       ↑
     改为反对    取消
           ↓       ↑
    ┌──────────────┐
    │  反对 (-1)   │
    └──────────────┘
           ↓ ↑
     取消投票└─┘
```

**所有合法的状态转换:**

| 当前状态 | 新操作 | 分数变化 | 结果状态 | 说明 |
|---------|--------|---------|---------|------|
| 0 (未投票) | +1 (赞成) | +432 | +1 | 首次投赞成票 |
| 0 (未投票) | -1 (反对) | -432 | -1 | 首次投反对票 |
| +1 (赞成) | 0 (取消) | -432 | 0 | 取消赞成票 |
| +1 (赞成) | -1 (反对) | -864 | -1 | 改投反对(差值=2) |
| -1 (反对) | 0 (取消) | +432 | 0 | 取消反对票 |
| -1 (反对) | +1 (赞成) | +864 | +1 | 改投赞成(差值=2) |
| +1 (赞成) | +1 (赞成) | 0 | +1 | ❌ 重复投票,报错 |
| -1 (反对) | -1 (反对) | 0 | -1 | ❌ 重复投票,报错 |
| 0 (未投票) | 0 (取消) | 0 | 0 | ❌ 无意义操作,报错 |

---

### 3.3 分数计算逻辑

**关键公式:**
```go
// 分数变化 = 操作方向 * 差值绝对值 * 单票分数
score_change = direction * |new_value - old_value| * 432

direction: 操作方向 (1表示加分, -1表示减分)
|new_value - old_value|: 新旧投票值的差值绝对值
```

**示例计算:**

**Case 1: 从未投票(0) → 赞成(+1)**
```
old_value = 0
new_value = 1
direction = 1 (加分)
diff = |1 - 0| = 1
score_change = 1 * 1 * 432 = +432
```

**Case 2: 从赞成(+1) → 反对(-1)**
```
old_value = 1
new_value = -1
direction = -1 (减分)
diff = |-1 - 1| = 2
score_change = -1 * 2 * 432 = -864
```

**Case 3: 从反对(-1) → 取消(0)**
```
old_value = -1
new_value = 0
direction = 1 (加分)
diff = |0 - (-1)| = 1
score_change = 1 * 1 * 432 = +432
```

---

## 4. 数据模型设计

### 4.1 投票参数结构体

```go
// models/params.go
package models

// ParamVoteData 投票参数
type ParamVoteData struct {
	// PostID: 目标帖子ID (必填)
	PostID int64 `json:"post_id" binding:"required"`

	// Direction: 投票方向 (必填)
	// 1: 赞成票
	// 0: 取消投票
	// -1: 反对票
	Direction int8 `json:"direction" binding:"required,oneof=1 0 -1"`
}
```

---

### 4.2 字段详解

**PostID 字段:**
```go
PostID int64 `json:"post_id" binding:"required"`
```

- **类型**: `int64` (Snowflake生成的ID)
- **标签**:
  - `json:"post_id"`: JSON序列化字段名
  - `binding:"required"`: 必填字段,为空会报错

**为什么是int64而不是string?**
- Snowflake生成的ID是int64类型
- 后续需要与数据库字段匹配
- 方便数值比较和排序

---

**Direction 字段:**
```go
Direction int8 `json:"direction" binding:"required,oneof=1 0 -1"`
```

- **类型**: `int8` (节省内存,范围-128~127足够)
- **标签**:
  - `json:"direction"`: JSON序列化字段名
  - `binding:"required"`: 必填字段
  - `binding:"oneof=1 0 -1"`: **核心校验** ← 重点!

**为什么是int8而不是int?**
```go
// ❌ 不好: 使用 int (占用8字节)
Direction int `json:"direction"`

// ✅ 好: 使用 int8 (仅占用1字节)
Direction int8 `json:"direction"`

// 如果有10万个投票记录:
// int:  100000 * 8 = 800KB
// int8: 100000 * 1 = 100KB
// 节省了 700KB 内存!
```

---

### 4.3 oneof校验标签详解

**什么是oneof?**

`oneof` 是 validator 库提供的校验标签,用于**限制字段的取值范围**。

**语法:**
```go
binding:"oneof=value1 value2 value3"
```

**含义:**
- 字段的值必须是 value1、value2、value3 之一
- 否则校验失败,返回错误

---

**在投票中的应用:**
```go
Direction int8 `json:"direction" binding:"required,oneof=1 0 -1"`
```

**效果:**

| 用户输入 | 校验结果 | 说明 |
|---------|---------|------|
| `1` | ✅ 通过 | 赞成票 |
| `0` | ✅ 通过 | 取消投票 |
| `-1` | ✅ 通过 | 反对票 |
| `2` | ❌ 失败 | 不在允许范围内 |
| `99` | ❌ 失败 | 不在允许范围内 |
| `-2` | ❌ 失败 | 不在允许范围内 |
| (空) | ❌ 失败 | required校验失败 |

---

**为什么不用自定义校验?**

**方案1: 手动校验 (不推荐)**
```go
func PostVoteHandler(c *gin.Context) {
	p := new(models.ParamVoteData)
	if err := c.ShouldBindJSON(p); err != nil {
		ResponseError(c, CodeInvalidParam)
		return
	}

	// ❌ 手动校验,代码冗余
	if p.Direction != 1 && p.Direction != 0 && p.Direction != -1 {
		ResponseErrorWithMsg(c, CodeInvalidParam, "direction must be 1, 0, or -1")
		return
	}

	// 业务逻辑...
}
```

**方案2: oneof校验 (推荐)**
```go
// ✅ 一行标签搞定,代码简洁
Direction int8 `json:"direction" binding:"required,oneof=1 0 -1"`
```

**对比:**
- 手动校验: 每个接口都要写重复代码
- oneof校验: 一次定义,自动生效
- oneof更符合**DRY原则**(Don't Repeat Yourself)

---

### 4.4 完整的参数校验流程

```go
// controller/vote.go
func PostVoteHandler(c *gin.Context) {
	// 1. 参数绑定和校验
	p := new(models.ParamVoteData)
	if err := c.ShouldBindJSON(p); err != nil {
		// 校验失败: PostID为空 或 Direction不在[1,0,-1]范围内
		zap.L().Error("PostVoteHandler with invalid param", zap.Error(err))
		ResponseError(c, CodeInvalidParam)
		return
	}

	// 2. 到这里,参数一定是合法的!
	// PostID: 非零int64
	// Direction: 1 或 0 或 -1

	// 3. 获取用户ID
	userID, exist := c.Get(CtxUserIDKey)
	if !exist {
		ResponseError(c, CodeNotLogin)
		return
	}

	// 4. 执行投票业务逻辑
	if err := logic.VoteForPost(userID.(int64), p); err != nil {
		zap.L().Error("logic.VoteForPost failed", zap.Error(err))
		ResponseError(c, CodeServerBusy)
		return
	}

	// 5. 返回成功响应
	ResponseSuccess(c, nil)
}
```

---

## 5. 投票接口设计

### 5.1 接口规范

**URL:** `POST /api/v1/vote`
**认证:** 需要JWT Token
**Content-Type:** application/json

---

### 5.2 请求示例

**投赞成票:**
```bash
curl -X POST "http://localhost:8080/api/v1/vote" \
  -H "Authorization: Bearer eyJhbGc..." \
  -H "Content-Type: application/json" \
  -d '{
    "post_id": "123456789",
    "direction": 1
  }'
```

**投反对票:**
```json
{
  "post_id": "123456789",
  "direction": -1
}
```

**取消投票:**
```json
{
  "post_id": "123456789",
  "direction": 0
}
```

---

### 5.3 响应示例

**成功响应:**
```json
{
  "code": 1000,
  "msg": "success",
  "data": null
}
```

**失败响应 - 参数错误:**
```json
{
  "code": 1002,
  "msg": "参数错误",
  "data": null
}
```

**失败响应 - 投票时间已过:**
```json
{
  "code": 5001,
  "msg": "投票时间已过",
  "data": null
}
```

**失败响应 - 重复投票:**
```json
{
  "code": 5002,
  "msg": "不允许重复投票",
  "data": null
}
```

---

## 6. 投票错误码设计

### 6.1 新增错误码

```go
// controller/code.go
const (
	CodeSuccess      = 1000
	CodeInvalidParam = 1002
	CodeServerBusy   = 1005

	// 投票相关错误码
	CodeVoteTimeExpire = 5001 // 投票时间已过
	CodeVoteRepeated   = 5002 // 不允许重复投票
)

var codeMsgMap = map[int]string{
	CodeSuccess:        "success",
	CodeInvalidParam:   "参数错误",
	CodeServerBusy:     "服务繁忙",
	CodeVoteTimeExpire: "投票时间已过",
	CodeVoteRepeated:   "不允许重复投票",
}
```

---

### 6.2 错误码使用场景

| 错误码 | 场景 | 触发条件 |
|-------|------|---------|
| 1002 | 参数错误 | PostID为空 或 Direction不在[1,0,-1] |
| 1005 | 服务繁忙 | Redis连接失败、未知异常 |
| 5001 | 投票时间已过 | 帖子发布超过7天 |
| 5002 | 重复投票 | 用户当前状态与新操作相同 |

---

## 7. 投票流程图

### 7.1 完整投票流程

```
用户点击投票按钮
        ↓
前端发送 POST /api/v1/vote
        ↓
[Controller] 参数校验 (PostID + Direction)
        ↓
[Controller] 获取用户ID (JWT中间件)
        ↓
[Logic] 调用投票逻辑
        ↓
[Redis] 检查帖子发布时间
        ↓
    时间>7天? ─Yes→ 返回"投票时间已过"
        ↓No
[Redis] 查询用户之前的投票记录
        ↓
   新旧值相同? ─Yes→ 返回"不允许重复投票"
        ↓No
[Redis] 计算分数变化
        ↓
[Redis Pipeline] 原子更新:
    - 更新帖子分数
    - 更新用户投票记录
        ↓
[Controller] 返回成功响应
        ↓
前端更新UI显示
```

---

### 7.2 分数计算示例图

```
场景: 用户从"赞成(+1)"改为"反对(-1)"

Step1: 读取旧投票值
  旧值: +1 (赞成票)

Step2: 接收新投票值
  新值: -1 (反对票)

Step3: 计算差值
  差值 = |-1 - 1| = 2

Step4: 判断操作方向
  新值 < 旧值 → direction = -1 (减分)

Step5: 计算分数变化
  score_change = -1 * 2 * 432 = -864

Step6: 更新帖子分数
  原分数: 1735820000
  新分数: 1735820000 - 864 = 1735819136

Step7: 更新用户投票记录
  ZSet: bluebell:post:voted:123456789
  Member: userID
  Score: -1 (更新为反对票)
```

---

## 8. 为什么使用Redis而不是MySQL?

### 8.1 性能对比

**场景: 10万用户同时给热门帖子投票**

**方案1: 使用MySQL**
```sql
-- 每次投票需要:
-- 1. 查询用户投票记录
SELECT * FROM vote WHERE user_id = ? AND post_id = ?;

-- 2. 查询帖子当前分数
SELECT score FROM post WHERE post_id = ?;

-- 3. 更新投票记录
INSERT INTO vote (user_id, post_id, direction) VALUES (?, ?, ?)
ON DUPLICATE KEY UPDATE direction = ?;

-- 4. 更新帖子分数
UPDATE post SET score = score + ? WHERE post_id = ?;

-- 问题:
-- - 4条SQL语句,需要事务保证一致性
-- - MySQL单表写入性能: ~1000 QPS
-- - 10万用户投票需要: 100秒
```

**方案2: 使用Redis**
```redis
# 每次投票需要:
ZSCORE bluebell:post:voted:123 user_id  # 查旧投票
ZINCRBY bluebell:post:score 432 123     # 更新分数
ZADD bluebell:post:voted:123 1 user_id  # 更新投票记录

# 使用Pipeline后,只需1次网络往返
# Redis ZSet写入性能: ~10万 QPS
# 10万用户投票需要: 1秒!
```

---

### 8.2 Redis的优势

| 维度 | MySQL | Redis | 优势方 |
|------|-------|-------|--------|
| **性能** | 1000 QPS | 100000 QPS | Redis |
| **延迟** | 5-10ms | 0.1-1ms | Redis |
| **排序** | ORDER BY (需要索引) | ZSet天然有序 | Redis |
| **并发** | 锁竞争严重 | 单线程,无锁 | Redis |
| **内存** | 磁盘存储 | 内存存储 | Redis |
| **持久化** | 强一致 | 可选持久化 | MySQL |
| **数据安全** | 高 | 中 | MySQL |

**结论:**
- **热数据**(投票、分数、排行)用Redis
- **冷数据**(帖子内容、用户信息)用MySQL
- **两者结合**,发挥各自优势

---

## 9. 常见问题

### Q1: 为什么不允许无限投票?

**A:** 如果允许一个用户多次投票:
- 刷票作弊成本极低
- 热榜被操纵,失去公信力
- 数据库压力巨大(每次投票都要写入)

**解决方案:** 一人一票 + 记录投票历史

---

### Q2: 为什么设置7天投票限制?

**A:**
1. **防止刷旧帖**: 避免恶意用户挖出几年前的旧帖刷票
2. **时效性**: 内容有生命周期,旧内容应该让位给新内容
3. **性能考虑**: Redis只需存储7天内的投票数据,节省内存

**Reddit的做法:**
- 发布6个月后,帖子自动归档(archive)
- 归档后不能投票、不能评论

---

### Q3: 为什么允许改票?

**A:**
- **用户体验**: 用户可能误点,允许改票更人性化
- **真实反馈**: 用户看完全文后可能改变想法
- **技术实现**: Redis ZSet天然支持更新分数

**不允许改票的缺点:**
- 用户体验差
- 需要额外机制防止误操作

---

### Q4: 为什么Direction是int8而不是bool?

**A:**

**如果用bool:**
```go
// ❌ 不好: 只能表示2种状态
type ParamVoteData struct {
	PostID int64 `json:"post_id"`
	IsUpvote bool `json:"is_upvote"` // true=赞成, false=反对
}

// 问题: 如何表示"取消投票"?
// 需要额外字段: IsCanceled bool
```

**使用int8:**
```go
// ✅ 好: 一个字段表示3种状态
Direction int8 `json:"direction"` // 1=赞成, 0=取消, -1=反对
```

**对比:**
- bool: 需要2个字段 (IsUpvote + IsCanceled)
- int8: 只需1个字段 (Direction)
- int8更简洁、更易维护

---

### Q5: oneof和enum有什么区别?

**A:**

**enum (枚举):**
```go
// Go中没有原生enum,需要用常量模拟
type Direction int8
const (
	DirectionDown Direction = -1
	DirectionNone Direction = 0
	DirectionUp   Direction = 1
)
```

**oneof (校验标签):**
```go
// 直接在结构体标签中定义
Direction int8 `json:"direction" binding:"oneof=1 0 -1"`
```

**区别:**
- enum: 在代码层面定义类型,需要类型转换
- oneof: 在校验层面限制取值,更灵活
- oneof更适合HTTP参数校验

---

## 10. 实战练习

### 练习1: 添加投票数查询接口

**任务:** 实现获取帖子当前投票数的接口

**要求:**
1. 返回赞成票数、反对票数、净投票数
2. URL: `GET /api/v1/post/:id/votes`

**提示:**
```go
// Redis层
func GetPostVoteData(postID string) (upVotes, downVotes int64, err error) {
	// 从 ZSet 中获取所有投票记录
	// 统计score > 0的数量 (赞成票)
	// 统计score < 0的数量 (反对票)
}
```

---

### 练习2: 实现投票记录查询

**任务:** 查询用户对某个帖子的投票状态

**要求:**
1. 返回: 1(已赞成), -1(已反对), 0(未投票)
2. URL: `GET /api/v1/post/:id/vote_status`

---

### 练习3: 批量查询投票状态

**任务:** 在帖子列表中显示当前用户对每个帖子的投票状态

**要求:**
1. 使用Redis Pipeline提高性能
2. 返回 map[postID]voteStatus

---

## 11. 本章总结

### 11.1 核心知识点

| 知识点 | 说明 |
|--------|------|
| **投票业务价值** | 内容筛选、用户参与、热度计算 |
| **Reddit算法** | 分数 = 时间戳 + 投票数*432 |
| **432的含义** | 200票 = 1天,抵消时间衰减 |
| **投票规则** | 一人一票、允许改票、7天限制 |
| **oneof校验** | 限制字段取值范围 |
| **状态机** | 0 ↔ 1 ↔ -1 的转换逻辑 |
| **Redis优势** | 高性能、低延迟、天然排序 |

---

### 11.2 设计思想

1. **简化原则**: 简化Reddit算法,保留核心思想
2. **防刷机制**: 时间窗口 + 重复检测
3. **用户体验**: 允许改票,错误提示友好
4. **技术选型**: Redis处理热数据,MySQL存储冷数据
5. **参数校验**: 使用oneof标签,避免重复代码

---

## 12. 延伸阅读

- [Reddit投票算法详解](https://medium.com/hacking-and-gonzo/how-reddit-ranking-algorithms-work-ef111e33d0d9)
- [Go validator库文档](https://github.com/go-playground/validator)
- [Redis ZSet数据结构](https://redis.io/docs/data-types/sorted-sets/)
- [分布式系统中的投票一致性](https://en.wikipedia.org/wiki/Consensus_(computer_science))

---

## 📖 下一章预告

投票的业务规则和参数校验已经完成,但核心的Redis实现还没有讲!

下一章,我们将深入学习:
- Redis ZSet数据结构详解
- 投票数据在Redis中的存储设计
- Pipeline原子性保证
- 帖子分数的实时更新
- 完整的投票功能实现

让我们进入Redis的世界! 🚀

---

**📖 下一章: [第17章:Redis在帖子排序中的应用](./17-Redis在帖子排序中的应用.md)**
