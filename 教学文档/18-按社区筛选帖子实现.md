# 第18章:按社区筛选帖子实现

> **本章导读**
>
> 现在我们已经实现了全站帖子的投票和排序,但用户还需要一个重要功能:**按社区筛选帖子**。
>
> 用户不想看到所有社区的混合内容,他们希望能够:只看"Go语言"社区的帖子、只看"前端开发"社区的帖子...
>
> 本章将学习如何设计统一的帖子查询接口,实现按社区筛选帖子的完整流程。

---

## 📚 本章目标

学完本章,你将掌握:

1. 理解按社区筛选的业务需求
2. 设计统一的帖子查询接口
3. 实现按社区筛选的完整流程
4. 理解条件查询的实现方法
5. 学习参数的扩展性设计
6. 掌握Logic层的调度器模式
7. 理解MySQL条件查询的优化
8. 学习接口的向后兼容策略

---

## 1. 业务需求分析

### 1.1 用户场景

**场景1: 浏览全站内容**
```
用户: 我想看看整个论坛最热门的帖子
需求: 不限社区,按热度排序
请求: GET /api/v1/posts2?order=score&page=1&size=10
```

---

**场景2: 浏览特定社区**
```
用户: 我只想看"Go语言"社区的帖子
需求: 限定社区ID=1,按时间排序
请求: GET /api/v1/posts2?community_id=1&order=time&page=1&size=10
```

---

**场景3: 社区热榜**
```
用户: 我想看"前端开发"社区的热门帖子
需求: 限定社区ID=2,按热度排序
请求: GET /api/v1/posts2?community_id=2&order=score&page=1&size=10
```

---

### 1.2 接口设计需求

**统一接口的设计原则:**
1. **一个接口满足所有场景** (不要为每个场景写一个接口)
2. **参数可选** (community_id为0或不传表示全站)
3. **向后兼容** (老接口继续可用)
4. **扩展性强** (未来可以加更多筛选条件)

---

## 2. 参数设计

### 2.1 参数结构体

**models/params.go**
```go
package models

// ParamPostList 获取帖子列表的参数
type ParamPostList struct {
	// Page: 页码(从1开始)
	Page int64 `json:"page" form:"page"`

	// Size: 每页条数
	Size int64 `json:"size" form:"size"`

	// Order: 排序方式 (time:按时间, score:按热度)
	Order string `json:"order" form:"order"`

	// CommunityID: 社区ID (可选)
	// 0 或 不传: 表示查询全站帖子
	// >0: 表示查询指定社区的帖子
	CommunityID int64 `json:"community_id" form:"community_id"`
}

// 排序规则常量
const (
	OrderTime  = "time"  // 按时间排序
	OrderScore = "score" // 按分数(热度)排序
)
```

---

### 2.2 字段详解

**Page 和 Size:**
```go
Page int64 `json:"page" form:"page"`
Size int64 `json:"size" form:"size"`
```
- 分页参数,之前章节已详细讲解
- `form` 标签允许从URL查询参数中绑定

---

**Order 字段:**
```go
Order string `json:"order" form:"order"`
```
- **作用**: 控制帖子的排序方式
- **取值**:
  - `"time"`: 按发布时间降序 (最新的在前)
  - `"score"`: 按热度分数降序 (最热的在前)

**为什么不用int?**
```go
// ❌ 不好: 数字不直观
Order int `json:"order"` // 1=时间, 2=分数

// ✅ 好: 字符串语义化
Order string `json:"order"` // "time" / "score"
```

---

**CommunityID 字段 (核心):**
```go
CommunityID int64 `json:"community_id" form:"community_id"`
```

**语义约定:**
```go
// CommunityID = 0 或 不传
// → 表示查询全站所有社区的帖子
// → 调用 GetPostList2(从Redis查询)

// CommunityID > 0
// → 表示查询指定社区的帖子
// → 调用 GetCommunityPostList(从MySQL查询)
```

**示例请求:**
```bash
# 全站帖子
GET /api/v1/posts2?page=1&size=10&order=score

# Go语言社区帖子 (community_id=1)
GET /api/v1/posts2?community_id=1&page=1&size=10&order=time

# 前端开发社区帖子 (community_id=2)
GET /api/v1/posts2?community_id=2&page=1&size=10&order=score
```

---

### 2.3 为什么不用binding校验?

**注意:** `CommunityID` 没有 `binding` 标签

```go
// 当前实现 (正确)
CommunityID int64 `json:"community_id" form:"community_id"`

// ❌ 错误示范: 加了 required
CommunityID int64 `json:"community_id" form:"community_id" binding:"required"`
```

**为什么?**
- `community_id` 是**可选参数**
- 不传表示查询全站,这是合法的
- 如果加 `required`,用户必须传,失去了灵活性

---

## 3. Controller层实现

### 3.1 升级版帖子列表接口

**controller/post.go**
```go
// GetPostListHandler2 升级版帖子列表接口
// @Summary 获取帖子列表(新版)
// @Description 升级版分页获取帖子列表接口,支持按社区和排序规则查询
// @Tags 帖子相关
// @Accept application/json
// @Produce application/json
// @Param Authorization header string true "Bearer 用户令牌"
// @Param page query int false "页码"
// @Param size query int false "每页数量"
// @Param order query string false "排序方式(time/score)"
// @Param community_id query int false "社区ID(0表示全站)"
// @Success 200 {object} ResponseData{data=[]models.ApiPostDetail}
// @Router /posts2 [get]
func GetPostListHandler2(c *gin.Context) {
	// 1. 设置默认参数
	p := &models.ParamPostList{
		Page:  1,                  // 默认第1页
		Size:  10,                 // 默认每页10条
		Order: models.OrderTime,   // 默认按时间排序
		// CommunityID 默认为 0 (表示全站)
	}

	// 2. 绑定查询参数
	// 从 URL 查询参数中提取 page、size、order、community_id
	if err := c.ShouldBindQuery(p); err != nil {
		zap.L().Error("GetPostListHandler2 with invalid param", zap.Error(err))
		ResponseError(c, CodeInvalidParam)
		return
	}

	// 3. 调用业务逻辑层
	// Logic层会根据 CommunityID 的值自动选择查询策略
	data, err := logic.GetPostListNew(p)
	if err != nil {
		zap.L().Error("logic.GetPostListNew failed", zap.Error(err))
		ResponseError(c, CodeServerBusy)
		return
	}

	// 4. 返回成功响应
	ResponseSuccess(c, data)
}
```

---

### 3.2 默认参数的设计

**为什么要设置默认值?**
```go
p := &models.ParamPostList{
	Page:  1,                // 默认第1页
	Size:  10,               // 默认每页10条
	Order: models.OrderTime, // 默认按时间排序
}
```

**好处:**
1. **用户体验**: 用户不传参数时也能正常使用
2. **向后兼容**: 老接口调用新接口也能work
3. **防御性编程**: 避免零值导致的问题

---

**参数覆盖机制:**
```go
// 1. 先设置默认值
p := &models.ParamPostList{Page: 1, Size: 10, Order: "time"}

// 2. 用户传的参数会覆盖默认值
c.ShouldBindQuery(p)

// 示例:
// 用户请求: ?page=2&order=score
// 结果: p.Page=2, p.Size=10(默认), p.Order="score", p.CommunityID=0(默认)
```

---

## 4. Logic层实现 - 调度器模式

### 4.1 调度器函数

**logic/post.go**
```go
// GetPostListNew 是一个新的、统一的帖子列表获取函数
// 它充当一个"调度器"或"分发器"
func GetPostListNew(p *models.ParamPostList) (data []*models.ApiPostDetail, err error) {

	// 关键判断:根据 CommunityID 是否为 0,来决定执行哪种查询逻辑
	if p.CommunityID == 0 {
		// 1. CommunityID 为 0 (或未提供)
		// 执行"查询所有帖子"的逻辑
		// GetPostList2 是原有的、用于获取所有帖子的逻辑函数
		data, err = GetPostList2(p)
	} else {
		// 2. CommunityID 不为 0 (已提供)
		// 执行"根据社区ID查询帖子"的逻辑
		// GetCommunityPostList 是原有的、用于按社区ID获取帖子的逻辑函数
		data, err = GetCommunityPostList(p)
	}

	// 统一的错误处理
	if err != nil {
		// 记录日志,方便排查问题
		zap.L().Error("logic.GetPostListNew failed", zap.Error(err))
		return nil, err
	}

	// 成功则返回数据和 nil 错误
	return data, nil
}
```

---

### 4.2 调度器模式详解

**什么是调度器?**

调度器(Dispatcher) 是一种设计模式,根据输入参数的不同,选择不同的处理逻辑。

```
请求参数
    ↓
调度器 (GetPostListNew)
    ↓
    ├─ CommunityID == 0? → 调用 GetPostList2() → 全站查询
    │
    └─ CommunityID != 0? → 调用 GetCommunityPostList() → 社区查询
```

---

**为什么要用调度器?**

**方案1: 两个独立接口 (不好)**
```go
// ❌ 不好: 接口分散,重复代码多
GET /api/v1/posts          // 全站帖子
GET /api/v1/community/:id/posts  // 社区帖子
```

**方案2: 统一接口 + 调度器 (好)**
```go
// ✅ 好: 一个接口,根据参数自动分发
GET /api/v1/posts2?community_id=0   // 全站
GET /api/v1/posts2?community_id=1   // 社区1
```

**好处:**
- **接口统一**: 前端只需对接一个接口
- **参数灵活**: 通过参数控制行为
- **代码复用**: Controller层代码不重复
- **易于扩展**: 未来可以加更多条件

---

### 4.3 两种查询逻辑的对比

**全站查询 (GetPostList2):**
```
流程:
1. 从 Redis ZSet 获取排序后的帖子ID列表
2. 根据 ID 列表从 MySQL 查询详情
3. 批量查询投票数据
4. 组装返回数据

优点:
- 利用Redis的排序能力
- 支持按时间和热度排序
- 性能高

缺点:
- 无法按社区筛选 (Redis中没有按社区分类存储)
```

---

**社区查询 (GetCommunityPostList):**
```
流程:
1. 直接从 MySQL 查询指定社区的帖子
2. 可以按时间排序 (ORDER BY create_time)
3. 逐个查询投票数据
4. 组装返回数据

优点:
- 支持按社区筛选
- 实现简单

缺点:
- 不支持按热度排序 (MySQL中没有分数字段)
- 性能略低于Redis
```

---

## 5. 按社区查询的完整实现

### 5.1 Logic层

**logic/post.go**
```go
// GetCommunityPostList 根据社区ID获取帖子列表
func GetCommunityPostList(p *models.ParamPostList) (data []*models.ApiPostDetail, err error) {
	// 按社区查询时,直接从 MySQL 查询
	// 因为 Redis 中没有按社区分类存储帖子 ID
	posts, err := mysql.GetPostListByCommunityID(p.CommunityID, p.Page, p.Size)
	if err != nil {
		zap.L().Error("mysql.GetPostListByCommunityID failed",
			zap.Int64("community_id", p.CommunityID),
			zap.Error(err))
		return nil, err
	}

	// 处理空数据情况
	if len(posts) == 0 {
		zap.L().Info("GetCommunityPostList: no posts found",
			zap.Int64("community_id", p.CommunityID))
		// 返回空切片而不是 nil
		data = make([]*models.ApiPostDetail, 0)
		return data, nil
	}

	// 初始化返回的数据切片
	data = make([]*models.ApiPostDetail, 0, len(posts))

	for _, post := range posts {
		// 根据 AuthorID 查询作者信息
		user, err := mysql.GetUserByID(post.AuthorID)
		if err != nil {
			zap.L().Error("mysql.GetUserByID failed",
				zap.Int64("author_id", post.AuthorID),
				zap.Error(err))
			continue
		}

		// 根据 CommunityID 查询社区信息
		community, err := mysql.GetCommunityDetailByID(post.CommunityID)
		if err != nil {
			zap.L().Error("mysql.GetCommunityDetailByID failed",
				zap.Int64("community_id", post.CommunityID),
				zap.Error(err))
			continue
		}

		// 从 Redis 获取投票数 (赞成票 - 反对票 = 净投票数)
		postIDStr := strconv.FormatInt(post.ID, 10)
		upVotes, downVotes, err := redis.GetPostVoteData(postIDStr)
		voteNum := upVotes - downVotes
		if err != nil {
			zap.L().Warn("redis.GetPostVoteData failed, using default 0",
				zap.Int64("post_id", post.ID),
				zap.Error(err))
			voteNum = 0
		}

		// 组装 API 详情数据结构
		postDetail := &models.ApiPostDetail{
			AuthorName:      user.Username,
			Post:            post,
			CommunityDetail: community,
			VoteNum:         voteNum,
		}
		data = append(data, postDetail)
	}

	return data, nil
}
```

---

### 5.2 DAO层实现

**dao/mysql/post.go**
```go
// GetPostListByCommunityID 根据社区ID查询帖子列表
func GetPostListByCommunityID(communityID, page, size int64) (posts []*models.Post, err error) {
	// 1. 构造SQL查询
	sqlStr := `SELECT post_id, title, content, author_id, community_id, create_time
	           FROM post
	           WHERE community_id = ? AND status = 1
	           ORDER BY create_time DESC
	           LIMIT ?,?`

	// 2. 计算分页偏移量
	offset := (page - 1) * size

	// 3. 执行查询
	posts = make([]*models.Post, 0, size)
	err = db.Select(&posts, sqlStr, communityID, offset, size)

	// 4. 处理空数据
	if err == sql.ErrNoRows {
		zap.L().Warn("no posts found in community",
			zap.Int64("community_id", communityID))
		err = nil // 没有数据不是错误
	}

	return
}
```

---

### 5.3 SQL详解

```sql
SELECT post_id, title, content, author_id, community_id, create_time
FROM post
WHERE community_id = ? AND status = 1
ORDER BY create_time DESC
LIMIT ?,?
```

**关键点:**

**WHERE 条件:**
```sql
WHERE community_id = ? AND status = 1
```
- `community_id = ?`: 筛选指定社区的帖子
- `status = 1`: 只查询正常状态的帖子 (过滤已删除/隐藏的帖子)

---

**ORDER BY:**
```sql
ORDER BY create_time DESC
```
- 按发布时间降序排序 (最新的在前)
- **注意**: 这里**不支持按热度排序**,因为MySQL表中没有score字段

**如果要支持按热度排序怎么办?**
```sql
-- 方案1: 在MySQL中加score字段 (需要同步更新)
SELECT * FROM post WHERE community_id = ? ORDER BY score DESC

-- 方案2: 在Redis中存储社区+分数的组合Key
-- bluebell:community:1:score (存储社区1的帖子分数)
-- 实现较复杂,本项目未实现
```

---

**LIMIT分页:**
```sql
LIMIT ?,?
```
- 第一个 `?`: offset (偏移量)
- 第二个 `?`: size (每页条数)

**示例:**
```sql
-- 第1页: LIMIT 0, 10
-- 第2页: LIMIT 10, 10
-- 第3页: LIMIT 20, 10
```

---

## 6. 完整的数据流转

### 6.1 全站查询流程

```
用户请求: GET /posts2?order=score&page=1&size=10
                    ↓
        [Controller] GetPostListHandler2
                    ↓
              解析参数: p.CommunityID = 0
                    ↓
          [Logic] GetPostListNew
                    ↓
         判断: CommunityID == 0? Yes
                    ↓
          [Logic] GetPostList2
                    ↓
      ┌─────────────┴─────────────┐
      ↓                           ↓
[Redis]                       [MySQL]
ZREVRANGE post:score 0 9      根据ID列表查询详情
返回: [123,456,789,...]        返回: [{Post},{Post},...]
      ↓                           ↓
[Redis Pipeline]            组装数据
批量查询投票数                ↓
返回: [10,5,20,...]         [Controller] 返回JSON
      └──────────┬────────────┘
                 ↓
           用户收到帖子列表
```

---

### 6.2 社区查询流程

```
用户请求: GET /posts2?community_id=1&page=1&size=10
                    ↓
        [Controller] GetPostListHandler2
                    ↓
              解析参数: p.CommunityID = 1
                    ↓
          [Logic] GetPostListNew
                    ↓
         判断: CommunityID != 0? Yes
                    ↓
        [Logic] GetCommunityPostList
                    ↓
              [MySQL] 条件查询
    WHERE community_id = 1 ORDER BY create_time DESC
              返回: [{Post},{Post},...]
                    ↓
            逐个查询作者和社区信息
                    ↓
          [Redis] 逐个查询投票数
                    ↓
               组装数据
                    ↓
          [Controller] 返回JSON
                    ↓
           用户收到社区帖子列表
```

---

## 7. 接口测试

### 7.1 查询全站帖子 (按时间排序)

**请求:**
```bash
curl -X GET "http://localhost:8080/api/v1/posts2?page=1&size=5&order=time" \
  -H "Authorization: Bearer eyJhbGc..."
```

**响应:**
```json
{
  "code": 1000,
  "msg": "success",
  "data": [
    {
      "id": "999",
      "title": "最新发布的帖子",
      "author_name": "张三",
      "community_id": "1",
      "communitydetail": {
        "id": "1",
        "name": "Go"
      },
      "vote_num": 10
    },
    // ...
  ]
}
```

---

### 7.2 查询全站帖子 (按热度排序)

**请求:**
```bash
curl -X GET "http://localhost:8080/api/v1/posts2?page=1&size=5&order=score" \
  -H "Authorization: Bearer eyJhbGc..."
```

**效果:** 返回热度最高的5个帖子

---

### 7.3 查询Go社区的帖子

**请求:**
```bash
curl -X GET "http://localhost:8080/api/v1/posts2?community_id=1&page=1&size=10&order=time" \
  -H "Authorization: Bearer eyJhbGc..."
```

**响应:**
```json
{
  "code": 1000,
  "msg": "success",
  "data": [
    {
      "id": "123",
      "title": "Go语言入门教程",
      "community_id": "1",  // ← 都是社区ID=1的帖子
      "communitydetail": {
        "id": "1",
        "name": "Go"
      }
    },
    // 所有帖子都属于Go社区
  ]
}
```

---

### 7.4 查询不存在的社区

**请求:**
```bash
curl -X GET "http://localhost:8080/api/v1/posts2?community_id=999&page=1&size=10" \
  -H "Authorization: Bearer eyJhbGc..."
```

**响应:**
```json
{
  "code": 1000,
  "msg": "success",
  "data": []  // ← 返回空数组,不是错误
}
```

---

## 8. 性能对比

### 8.1 全站查询性能

**数据量:** 10万条帖子

| 操作 | 耗时 | 说明 |
|------|------|------|
| Redis ZREVRANGE | 2ms | 查询前10个ID |
| MySQL IN查询 | 5ms | 根据ID查询详情 |
| Redis Pipeline | 1ms | 批量查询投票数 |
| **总耗时** | **8ms** | 非常快! |

---

### 8.2 社区查询性能

**数据量:** 1万条社区1的帖子

| 操作 | 耗时 | 说明 |
|------|------|------|
| MySQL WHERE查询 | 10ms | 带索引的条件查询 |
| 逐个查询作者(N+1) | 20ms | 10次查询 * 2ms |
| 逐个查询投票(N+1) | 10ms | 10次查询 * 1ms |
| **总耗时** | **40ms** | 较慢,可优化 |

---

### 8.3 优化方案

**优化1: 批量查询作者和社区**
```go
// ❌ 不好: N+1查询
for _, post := range posts {
	user, _ := mysql.GetUserByID(post.AuthorID)
	community, _ := mysql.GetCommunityDetailByID(post.CommunityID)
}

// ✅ 好: 批量查询
userIDs := collectUserIDs(posts)
users := mysql.GetUsersByIDs(userIDs) // 1次查询
```

**效果:** 从20ms降到2ms

---

**优化2: 使用Redis Pipeline查询投票**
```go
// ✅ 已经在用: GetPostsVoteData使用Pipeline
voteData, _ := redis.GetPostsVoteData(postIDs)
```

---

**优化后总耗时:**
```
MySQL查询: 10ms
批量查询作者: 2ms
Redis Pipeline投票: 1ms
总耗时: 13ms (提升了3倍!)
```

---

## 9. 常见问题

### Q1: 为什么社区查询不支持按热度排序?

**A:**

**原因:**
- MySQL post表中没有score字段
- score存储在Redis中,MySQL不知道
- 跨存储查询会很复杂

**解决方案:**

**方案1: MySQL表中加score字段 (同步方案)**
```sql
ALTER TABLE post ADD COLUMN score BIGINT DEFAULT 0;

-- 投票时同时更新MySQL
UPDATE post SET score = score + 432 WHERE post_id = ?;

-- 查询时就可以按score排序
SELECT * FROM post WHERE community_id = 1 ORDER BY score DESC;
```

**缺点:** 需要双写,数据一致性问题

---

**方案2: Redis中存储社区+分数组合Key**
```redis
# 为每个社区单独维护一个分数ZSet
ZADD bluebell:community:1:score 1735820432 "123"
ZADD bluebell:community:1:score 1735819500 "456"

# 查询时从这个ZSet获取
ZREVRANGE bluebell:community:1:score 0 9
```

**缺点:**
- 需要在发帖和投票时多写一份数据
- Redis内存占用增加
- 实现复杂度高

---

**Bluebell的选择:**
- 全站查询: Redis排序 (支持按时间和热度)
- 社区查询: MySQL排序 (只支持按时间)
- **原因**: 简化实现,社区查询按时间排序已满足大部分需求

---

### Q2: 为什么要用调度器模式?

**A:**

**对比两种方案:**

**方案1: 两个独立接口**
```go
// 全站帖子
GET /api/v1/posts

// 社区帖子
GET /api/v1/community/:id/posts
```

**缺点:**
- 前端需要判断调用哪个接口
- 代码重复(分页、参数校验、错误处理)
- 后续扩展麻烦(加筛选条件需要改两个接口)

---

**方案2: 统一接口 + 调度器**
```go
// 统一接口
GET /api/v1/posts2?community_id=0   // 全站
GET /api/v1/posts2?community_id=1   // 社区
```

**优点:**
- 前端只需对接一个接口
- 参数灵活,通过query控制行为
- 代码复用,易于维护
- 扩展性强(未来可加更多筛选条件)

---

### Q3: 空数据应该返回null还是[]?

**A:**

**❌ 不好: 返回null**
```json
{
  "code": 1000,
  "msg": "success",
  "data": null  // ← 前端会报错
}
```

**问题:**
```javascript
// 前端代码
data.data.forEach(post => {
  // TypeError: Cannot read property 'forEach' of null
})
```

---

**✅ 好: 返回空数组[]**
```json
{
  "code": 1000,
  "msg": "success",
  "data": []  // ← 前端可以正常遍历
}
```

**前端代码:**
```javascript
data.data.forEach(post => {
  // 正常执行,只是循环0次
})
```

---

**Go代码实现:**
```go
// ❌ 错误: 返回nil切片
var data []*models.ApiPostDetail
return data, nil

// ✅ 正确: 返回空切片
data := make([]*models.ApiPostDetail, 0)
return data, nil
```

---

## 10. 本章总结

### 10.1 核心知识点

| 知识点 | 说明 |
|--------|------|
| **统一接口设计** | 一个接口支持多种查询场景 |
| **参数扩展性** | community_id可选,0表示全站 |
| **调度器模式** | 根据参数选择不同的处理逻辑 |
| **条件查询** | MySQL WHERE + LIMIT实现筛选 |
| **空数据处理** | 返回空切片而不是nil |
| **默认参数** | 提升用户体验和向后兼容性 |

---

### 10.2 设计模式总结

**调度器模式的优势:**
```
统一接口
    ↓
根据参数分发
    ↓
调用不同逻辑
    ↓
统一返回格式
```

**适用场景:**
- 多种查询条件
- 不同数据源
- 条件查询
- 策略模式

---

### 10.3 接口演进过程

```
v1: /posts
  只支持全站查询,按时间排序

v2: /posts2
  支持按时间和热度排序

v3: /posts2?community_id=1
  支持按社区筛选

未来: /posts2?community_id=1&tag=golang&author=123
  支持更多筛选条件
```

**设计原则:**
- 向后兼容
- 参数可选
- 易于扩展

---

## 11. 延伸阅读

- [RESTful API设计最佳实践](https://restfulapi.net/)
- [Go接口设计模式](https://golang.org/doc/effective_go.html)
- [MySQL索引优化](https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html)
- [调度器模式详解](https://en.wikipedia.org/wiki/Dispatcher_pattern)

---

## 📖 后续章节预告

恭喜你!到这里,Bluebell项目的核心功能已经全部实现:
✅ 用户注册登录
✅ JWT认证
✅ 社区管理
✅ 帖子发布
✅ 帖子列表(分页、排序、筛选)
✅ 投票功能

后续章节将关注:
- Swagger API文档生成
- 前后端联调
- 性能优化
- 部署上线

让我们继续完善这个项目! 🚀

---

**📖 推荐继续学习原有教学文档中的后续章节,了解Swagger集成、API文档生成等内容!**
