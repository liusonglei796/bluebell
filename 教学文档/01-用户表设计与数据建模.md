# 第01章: 用户表设计与数据建模

> **学习目标**: 理解 Web 应用用户表的设计原则,掌握 MySQL 数据类型选择、索引设计和字符集配置。

---

## 📚 本章导读

用户表是每个 Web 应用的核心基石。一个设计良好的用户表不仅能保证数据安全和完整性,还能为未来的功能扩展预留空间。

本章将深入讲解 Bluebell 项目的用户表设计,涵盖:

1. 为什么需要双 ID 设计(自增 ID vs 业务 ID)
2. 如何选择合适的字段类型和长度
3. 索引设计的最佳实践
4. utf8mb4 字符集的重要性
5. 时间戳字段的自动化管理

---

## 1. 为什么用户表如此重要?

用户表是应用的"身份证系统",它承担三大核心职责:

### 1.1 认证 (Authentication)

**职责:** 确认 "你是你"

用户通过用户名和密码证明自己的身份。这个过程依赖用户表存储的凭证信息。

### 1.2 授权 (Authorization)

**职责:** 明确 "你能做什么"

通过用户表中的角色字段(如 `role` 或 `permission`),系统可以判断用户的权限级别。

### 1.3 资料存储 (Profile)

**职责:** 保存用户的个人信息

包括邮箱、性别、头像、创建时间等,为个性化服务提供数据支持。

---

## 2. Bluebell 用户表完整设计

### 2.1 表结构 SQL

```sql
-- ============================================
-- Bluebell 项目 - 用户表 (user)
-- ============================================

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
    -- ============================================
    -- 主键与业务 ID
    -- ============================================
    `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID (数据库内部使用)',
    `user_id` BIGINT(20) NOT NULL COMMENT '用户ID (业务层使用,雪花算法生成)',

    -- ============================================
    -- 认证字段
    -- ============================================
    `username` VARCHAR(64) COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户名 (登录凭证)',
    `password` VARCHAR(64) COLLATE utf8mb4_general_ci NOT NULL COMMENT '密码 (bcrypt 哈希值)',

    -- ============================================
    -- 用户资料
    -- ============================================
    `email` VARCHAR(64) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '电子邮箱',
    `gender` TINYINT(4) NOT NULL DEFAULT 0 COMMENT '性别 (0=未知, 1=男, 2=女)',

    -- ============================================
    -- 时间戳
    -- ============================================
    `create_time` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',

    -- ============================================
    -- 索引与约束
    -- ============================================
    PRIMARY KEY (`id`),
    UNIQUE KEY `idx_username` (`username`) USING BTREE,
    UNIQUE KEY `idx_user_id` (`user_id`) USING BTREE

) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='用户表';
```

### 2.2 在 GoLand 中执行建表

#### 步骤 1: 连接数据库

1. 点击 GoLand 右侧边栏的 **"Database"** 图标
2. 点击 `+` → `Data Source` → `MySQL`
3. 填写连接信息:
   ```
   Host: localhost
   Port: 3306
   User: root
   Password: [你的密码]
   Database: bluebell
   ```
4. 点击 **"Test Connection"**,确认连接成功
5. 点击 **"Apply"** → **"OK"**

#### 步骤 2: 执行 SQL

1. 在 Database 窗口中,右键点击数据库 → **"New"** → **"Query Console"**
2. 粘贴上面的 SQL 代码
3. 点击绿色的"执行"按钮(或按 `Ctrl+Enter`)
4. 刷新数据库,确认表创建成功

---

## 3. 字段详解:逐个击破

### 3.1 主键字段: `id`

```sql
`id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID (数据库内部使用)'
```

#### 为什么使用 BIGINT?

| 数据类型 | 字节数 | 最大值 | 是否够用? |
|---------|--------|--------|----------|
| `INT` | 4 字节 | 约 21 亿 | ❌ 大型应用可能不够 |
| `BIGINT` | 8 字节 | 约 922 京 | ✅ 足够任何规模 |

**设计原则:** 面向未来的可扩展性。即使应用初期用户很少,也应该使用 `BIGINT`,避免日后痛苦的数据迁移。

#### 为什么使用 AUTO_INCREMENT?

```sql
-- 插入数据时无需指定 id
INSERT INTO user (user_id, username, password) VALUES (123456, 'alice', 'hash...');

-- MySQL 自动分配 id = 1
```

`AUTO_INCREMENT` 让数据库自动生成递增的主键,开发者无需手动管理。

---

### 3.2 业务 ID: `user_id`

```sql
`user_id` BIGINT(20) NOT NULL COMMENT '用户ID (业务层使用,雪花算法生成)'
```

#### 为什么需要两个 ID?

**问题:** 如果直接暴露自增 ID 会怎样?

```
GET /api/v1/users/1   ✅ 查询成功
GET /api/v1/users/2   ✅ 查询成功
GET /api/v1/users/3   ✅ 查询成功
...
```

**安全风险:**
1. **可遍历性:** 黑客可以轻松遍历所有用户
2. **信息泄露:** 暴露了用户总量(从 1 到最大值)
3. **可预测性:** 容易预测下一个用户的 ID

**解决方案:** 使用雪花算法生成 `user_id`

```go
// 雪花算法生成的 ID 示例
user_id = 256294141623799808  // 不连续、不可预测
```

#### 雪花算法的优势

| 特性 | 自增 ID | 雪花算法 |
|-----|--------|---------|
| 可预测性 | 高 | 低 |
| 安全性 | 差 | 好 |
| 分布式友好 | 差 | 优秀 |
| 性能 | 高 | 高 |

**实现位置:** `pkg/snowflake/snowflake.go`

详细实现请参考 [第02章: Snowflake 算法生成分布式 ID](./02-Snowflake算法生成分布式ID.md)

---

### 3.3 认证字段: `username` 和 `password`

```sql
`username` VARCHAR(64) COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户名 (登录凭证)',
`password` VARCHAR(64) COLLATE utf8mb4_general_ci NOT NULL COMMENT '密码 (bcrypt 哈希值)',
```

#### 为什么选择 VARCHAR(64)?

**VARCHAR vs CHAR 对比:**

```sql
-- CHAR(64): 固定长度
-- 存储 "alice" (5字符) 也会占用 64 字节
INSERT INTO user (username) VALUES ('alice');  -- 浪费 59 字节

-- VARCHAR(64): 可变长度
-- 存储 "alice" 只占用 5 字节 + 1-2 字节长度信息
INSERT INTO user (username) VALUES ('alice');  -- 节省空间 ✅
```

#### ⚠️ 密码字段的安全规范

**错误做法:**
```sql
-- ❌ 绝对不能明文存储密码!
INSERT INTO user (password) VALUES ('123456');
```

**正确做法:**
```go
// 使用 bcrypt 进行哈希
hashedPassword, _ := bcrypt.GenerateFromPassword([]byte("123456"), bcrypt.DefaultCost)

// 存储的是哈希值 (60字符)
// $2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy
```

**为什么是 VARCHAR(64)?**
- bcrypt 生成的哈希值固定为 60 个字符
- VARCHAR(64) 预留了一些空间,足够存储哈希值

详细实现请参考 [第06章: 用户密码加密与数据持久化](./06-用户密码加密与数据持久化.md)

---

### 3.4 用户资料: `email` 和 `gender`

#### email 字段

```sql
`email` VARCHAR(64) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '电子邮箱',
```

**设计说明:**
- 允许为空(`DEFAULT NULL`),因为用户注册时可能不提供邮箱
- 长度为 64 字符(一般够用,生产环境建议 `VARCHAR(254)`)

#### gender 字段

```sql
`gender` TINYINT(4) NOT NULL DEFAULT 0 COMMENT '性别 (0=未知, 1=男, 2=女)',
```

**为什么用数字而不用字符串?**

| 方案 | 优点 | 缺点 |
|------|------|------|
| `VARCHAR` 存储 "男"/"女" | 直观 | 占用 3-9 字节,查询慢 |
| `TINYINT` 存储 0/1/2 | 只占 1 字节,查询快 | 需要约定映射关系 |

**映射关系:**
```go
const (
    GenderUnknown = 0  // 未知
    GenderMale    = 1  // 男
    GenderFemale  = 2  // 女
)
```

**默认值:** `DEFAULT 0` 表示用户未填写时默认为"未知"。

---

### 3.5 时间戳: `create_time` 和 `update_time`

```sql
`create_time` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
`update_time` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
```

#### create_time: 自动记录创建时间

```sql
INSERT INTO user (username, password) VALUES ('alice', 'hash...');

-- MySQL 自动设置 create_time 为当前时间 ✅
-- 开发者无需在 Go 代码中手动设置
```

#### update_time: 自动记录更新时间

```sql
-- 初次插入
INSERT INTO user (...) VALUES (...);
-- update_time = 2025-12-08 10:00:00

-- 修改邮箱
UPDATE user SET email = 'new@example.com' WHERE id = 1;
-- update_time 自动更新为 2025-12-08 11:30:00 ✅
```

**`ON UPDATE CURRENT_TIMESTAMP` 的魔力:**
- 每次 `UPDATE` 操作都会自动更新 `update_time`
- 开发者完全不用关心时间字段的维护
- 对于调试和数据审计非常有用

---

## 4. 索引设计:性能保障

```sql
PRIMARY KEY (`id`),
UNIQUE KEY `idx_username` (`username`) USING BTREE,
UNIQUE KEY `idx_user_id` (`user_id`) USING BTREE
```

### 4.1 主键索引

```sql
PRIMARY KEY (`id`)
```

**作用:**
1. 保证 `id` 的唯一性
2. 自动创建聚簇索引(InnoDB),查询速度极快
3. 所有其他索引都依赖主键索引

**查询优化:**
```sql
-- 使用主键查询,速度极快
SELECT * FROM user WHERE id = 1;  -- O(log n)
```

### 4.2 唯一索引: username

```sql
UNIQUE KEY `idx_username` (`username`) USING BTREE
```

**作用:**
1. **保证唯一性:** 防止用户名重复
2. **加速查询:** 登录时通过用户名查询用户

**数据库层面的约束:**
```sql
-- 第一次插入
INSERT INTO user (username) VALUES ('alice');  -- ✅ 成功

-- 第二次插入相同用户名
INSERT INTO user (username) VALUES ('alice');  -- ❌ 失败
-- Error: Duplicate entry 'alice' for key 'idx_username'
```

这是**最强的数据完整性保证**,比在应用层检查更可靠。

### 4.3 唯一索引: user_id

```sql
UNIQUE KEY `idx_user_id` (`user_id`) USING BTREE
```

**作用:**
1. 保证业务 ID 的全局唯一性
2. 加速通过 `user_id` 的查询

**查询场景:**
```sql
-- 根据业务 ID 查询用户(常用于 API 接口)
SELECT * FROM user WHERE user_id = 256294141623799808;
```

---

## 5. 存储引擎与字符集

### 5.1 存储引擎: InnoDB

```sql
ENGINE=InnoDB
```

**为什么选择 InnoDB?**

| 特性 | InnoDB | MyISAM |
|------|--------|--------|
| 事务支持 | ✅ 支持 | ❌ 不支持 |
| 行级锁 | ✅ 支持(高并发) | ❌ 表锁 |
| 外键约束 | ✅ 支持 | ❌ 不支持 |
| 崩溃恢复 | ✅ 自动恢复 | ❌ 手动修复 |

**结论:** 现代 Web 应用**必须使用 InnoDB**。

### 5.2 字符集: utf8mb4

```sql
DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci
```

#### utf8 vs utf8mb4

| 字符集 | 最大字节数 | 支持 Emoji | 推荐使用 |
|--------|----------|------------|---------|
| `utf8` | 3 字节 | ❌ 不支持 | ❌ 不推荐 |
| `utf8mb4` | 4 字节 | ✅ 完全支持 | ✅ 强烈推荐 |

#### 实际问题演示

**使用 utf8 时:**
```sql
-- 创建表
CREATE TABLE test (name VARCHAR(64)) CHARSET=utf8;

-- 插入 Emoji
INSERT INTO test (name) VALUES ('张三 😀');  -- ❌ 报错!
-- Error: Incorrect string value: '\xF0\x9F\x98\x80' for column 'name'
```

**使用 utf8mb4 时:**
```sql
-- 创建表
CREATE TABLE test (name VARCHAR(64)) CHARSET=utf8mb4;

-- 插入 Emoji
INSERT INTO test (name) VALUES ('张三 😀');  -- ✅ 成功!
```

#### COLLATE 排序规则

```sql
COLLATE=utf8mb4_general_ci
```

- `general`: 通用排序规则
- `ci` (Case Insensitive): 不区分大小写

**实际效果:**
```sql
SELECT * FROM user WHERE username = 'Alice';   -- 可以匹配 'alice'
SELECT * FROM user WHERE username = 'ALICE';   -- 可以匹配 'alice'
```

---

## 6. Go 代码对应的 Model 结构体

创建文件: `models/user.go`

```go
package models

import "time"

// User 用户模型 - 对应数据库 user 表
type User struct {
	ID         int64     `db:"id"`          // 主键 ID
	UserID     int64     `db:"user_id"`     // 业务 ID (雪花算法生成)
	Username   string    `db:"username"`    // 用户名
	Password   string    `db:"password"`    // 密码 (bcrypt 哈希值)
	Email      string    `db:"email"`       // 电子邮箱
	Gender     int8      `db:"gender"`      // 性别 (0=未知, 1=男, 2=女)
	CreateTime time.Time `db:"create_time"` // 创建时间
	UpdateTime time.Time `db:"update_time"` // 更新时间
}
```

**注意事项:**
1. 使用 `db` 标签映射数据库字段名
2. Go 类型与 MySQL 类型的对应:
   - `BIGINT` → `int64`
   - `VARCHAR` → `string`
   - `TINYINT` → `int8`
   - `TIMESTAMP` → `time.Time`

---

## 7. 知识回顾与总结

### 7.1 核心要点

1. **双 ID 设计**:
   - `id` 用于数据库内部(自增、高效)
   - `user_id` 用于业务层(安全、不可预测)

2. **字段类型选择**:
   - 使用 `BIGINT` 而不是 `INT`,为未来留足空间
   - 使用 `VARCHAR` 而不是 `CHAR`,节省存储空间
   - 使用 `TINYINT` 存储枚举值,高效且节约

3. **安全规范**:
   - **绝对不能明文存储密码**,必须使用 bcrypt 哈希
   - 使用唯一索引保证数据完整性

4. **自动化管理**:
   - 利用 `DEFAULT CURRENT_TIMESTAMP` 自动设置创建时间
   - 利用 `ON UPDATE CURRENT_TIMESTAMP` 自动更新修改时间

5. **字符集选择**:
   - **必须使用 utf8mb4**,完美支持 Emoji 和所有语言

### 7.2 设计模式

```
┌─────────────────────────────────────┐
│        用户表设计三大原则           │
├─────────────────────────────────────┤
│ 1. 安全优先: 双ID + 密码哈希       │
│ 2. 性能考量: 合适的类型 + 索引     │
│ 3. 未来兼容: BIGINT + utf8mb4      │
└─────────────────────────────────────┘
```

---

## 8. 课后练习

### 练习 1: 扩展用户表

为用户表添加以下字段,并说明你的设计理由:

1. `avatar` - 用户头像 URL
2. `status` - 用户状态(正常/禁用/注销)
3. `last_login_time` - 最后登录时间

**提示:** 思考字段类型、长度、默认值和索引。

### 练习 2: 查询优化

编写 SQL 查询,实现以下功能:

1. 查询最近一周注册的用户
2. 查询性别为男性的用户数量
3. 根据用户名模糊搜索用户

### 练习 3: 数据迁移

思考:如果要将现有的 `INT` 类型的 `id` 字段升级为 `BIGINT`,应该如何操作?

---

## 9. 延伸阅读

- [第02章: Snowflake 算法生成分布式 ID](./02-Snowflake算法生成分布式ID.md)
- [第06章: 用户密码加密与数据持久化](./06-用户密码加密与数据持久化.md)
- [附录A: MySQL 数据类型详解](./附录/A03-MySQL查询优化指南.md)

---

## 10. 常见问题 FAQ

### Q1: 为什么不直接用 UUID 作为主键?

**A:** UUID 虽然全局唯一,但有以下缺点:
- 占用 36 字节(字符串)或 16 字节(二进制),比 BIGINT(8字节)大
- 无序,插入性能差,索引效率低
- 不适合作为 InnoDB 的聚簇索引

### Q2: user_id 可以用字符串类型吗?

**A:** 不推荐。字符串类型:
- 占用更多存储空间
- 查询和比较性能较差
- 雪花算法生成的是 int64,存储为字符串浪费空间

### Q3: 为什么 email 字段可以为 NULL?

**A:** 因为用户注册时可能不提供邮箱。如果设置为 `NOT NULL`,则必须提供默认值(如空字符串),但空字符串和真正的"未填写"语义不同,`NULL` 更准确表示"未提供"。

---

**下一章:** [第02章: Snowflake 算法生成分布式 ID](./02-Snowflake算法生成分布式ID.md)

**返回目录:** [README.md](./README.md)
