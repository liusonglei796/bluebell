# ç¬¬10ç« :å•ç‚¹ç™»å½•ä¸äº’è¸¢æ¨¡å¼

> **æœ¬ç« å¯¼è¯»**
>
> ä»€ä¹ˆæ˜¯**å•ç‚¹ç™»å½• (SSO - Single Sign On)**?åœ¨å¹¿ä¹‰ä¸Šå®ƒæŒ‡"ä¸€å¤„ç™»å½•,å¤„å¤„è®¿é—®"ã€‚ä½†åœ¨ç§»åŠ¨äº’è”ç½‘æ—¶ä»£,å®ƒå¸¸æŒ‡**"å•è®¾å¤‡ç™»å½•"**,å³åŒä¸€è´¦å·åŒä¸€æ—¶é—´åªèƒ½åœ¨ä¸€ä¸ªè®¾å¤‡åœ¨çº¿ã€‚å½“ä½ åœ¨æ‰‹æœº B ä¸Šç™»å½•æ—¶,æ‰‹æœº A ä¼šè‡ªåŠ¨ä¸‹çº¿(è¢«è¸¢)ã€‚
>
> ä¼ ç»Ÿçš„ Session æ¨¡å¼å¤©ç„¶æ”¯æŒè¿™ä¸€ç‚¹(æœåŠ¡å™¨åˆ é™¤æ—§ Session å³å¯),ä½†æ— çŠ¶æ€çš„ JWT è¯¥å¦‚ä½•å®ç°?æœ¬ç« å°†ç»“åˆ Redis å®ç°è¿™ä¸€åŠŸèƒ½,å¹¶æ·±å…¥æ¢è®¨å¤šè®¾å¤‡ç®¡ç†ã€å®‰å…¨éšæ‚£å’Œæœ€ä½³å®è·µã€‚

---

## ğŸ“š æœ¬ç« ç›®æ ‡

å­¦å®Œæœ¬ç« ,ä½ å°†æŒæ¡:

1. ç†è§£åŸºäº Redis çš„ JWT çŠ¶æ€ç®¡ç†æ–¹æ¡ˆçš„è®¾è®¡åŸç†
2. æŒæ¡ Redis Key çš„è®¾è®¡æ¨¡å¼å’Œæœ€ä½³å®è·µ
3. å®ç°å•ç‚¹ç™»å½•(äº’è¸¢)å’Œå¤šè®¾å¤‡ç®¡ç†ä¸¤ç§æ¨¡å¼
4. åœ¨ç™»å½•ã€åˆ·æ–°ã€ç™»å‡ºæ—¶æ­£ç¡®æ›´æ–° Redis çŠ¶æ€
5. åœ¨ä¸­é—´ä»¶ä¸­å®ç°é«˜æ•ˆçš„äº’è¸¢æ ¡éªŒé€»è¾‘
6. è§£å†³å¹¶å‘ç™»å½•çš„å®‰å…¨éšæ‚£å’Œè¾¹ç¼˜æƒ…å†µ
7. å®ç°è®¾å¤‡ç®¡ç†å’Œåœ¨çº¿çŠ¶æ€ç›‘æ§

---

## 1. æ ¸å¿ƒåŸç†æ·±åº¦å‰–æ

### 1.1 æ— çŠ¶æ€ JWT çš„å›°å¢ƒ

JWT çš„æ ¸å¿ƒä¼˜åŠ¿æ˜¯**æ— çŠ¶æ€**,ä½†è¿™ä¹Ÿå¸¦æ¥äº†ä¸€ä¸ªè‡´å‘½é—®é¢˜:

```
ç”¨æˆ·åœ¨è®¾å¤‡ A ç™»å½• â†’ è·å¾— Token_A (æœ‰æ•ˆæœŸ 10 åˆ†é’Ÿ)
  â†“
ç”¨æˆ·åœ¨è®¾å¤‡ B ç™»å½• â†’ è·å¾— Token_B (æœ‰æ•ˆæœŸ 10 åˆ†é’Ÿ)
  â†“
é—®é¢˜: Token_A å’Œ Token_B éƒ½æœ‰æ•ˆ!
  â†“
æœåŠ¡å™¨æ— æ³•è¯†åˆ« Token_A å·²ç»"è¿‡æ—¶"
  â†“
ç”¨æˆ·å¯ä»¥åœ¨ä¸¤ä¸ªè®¾å¤‡ä¸ŠåŒæ—¶æ“ä½œ (å®‰å…¨é£é™©)
```

**ä¼ ç»Ÿ Session çš„è§£å†³æ–¹æ¡ˆ:**

```go
// Session æ¨¡å¼ (å¤©ç„¶æ”¯æŒäº’è¸¢)
func Login(userID int64) sessionID string {
    // 1. åˆ é™¤è¯¥ç”¨æˆ·çš„æ—§ Session
    sessionStore.Delete("session:" + userID)

    // 2. åˆ›å»ºæ–° Session
    newSessionID := uuid.New()
    sessionStore.Set("session:" + userID, newSessionID)

    return newSessionID
}
```

**JWT çš„å›°å¢ƒ:**

```go
// JWT æ¨¡å¼ (æ— æ³•äº’è¸¢)
func Login(userID int64) token string {
    // ç”Ÿæˆæ–° Token
    newToken := jwt.Sign(userID, secret)

    // é—®é¢˜: æ—§ Token ä¾ç„¶æœ‰æ•ˆ!
    // æœåŠ¡å™¨æ²¡æœ‰å­˜å‚¨ä»»ä½•çŠ¶æ€,æ— æ³•çŸ¥é“æ—§ Token çš„å­˜åœ¨

    return newToken
}
```

### 1.2 Redis è§£å†³æ–¹æ¡ˆ

æˆ‘ä»¬å¼•å…¥ Redis ä½œä¸º**æƒå¨çš„çŠ¶æ€ä¸­å¿ƒ**,å°† JWT çš„"æ— çŠ¶æ€"è½¬å˜ä¸º"è½»çŠ¶æ€"ã€‚

**æ ¸å¿ƒè§„åˆ™:**

1. **Redis æ˜¯å”¯ä¸€çš„çœŸç›¸æ¥æº**: Redis ä¸­åªä¿å­˜è¯¥ç”¨æˆ·**å½“å‰å”¯ä¸€æœ‰æ•ˆ**çš„ Access Tokenã€‚
2. **ç™»å½•å³è¦†ç›–**: ç”Ÿæˆæ–° Token æ—¶,å†™å…¥ Redis (`SET user:token:{uid} new_token`),è¦†ç›–æ—§å€¼ã€‚
3. **åŒé‡æ ¡éªŒ**: ä¸­é—´ä»¶ä¸ä»…éªŒè¯ JWT ç­¾å,è¿˜å¯¹æ¯” `Request.Token == Redis.Token`ã€‚

**æ¶æ„ç¤ºæ„å›¾:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å®¢æˆ·ç«¯    â”‚
â”‚ (è®¾å¤‡ A/B)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ HTTP Request
       â”‚ Header: Authorization: Bearer {token}
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ JWT ä¸­é—´ä»¶  â”‚
â”‚             â”‚
â”‚ 1. éªŒè¯ç­¾å â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. æŸ¥è¯¢Redisâ”‚            â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜            â”‚
       â”‚                   â”‚
       â”‚ Get token         â”‚
       â†“                   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Redis    â”‚      â”‚   JWT    â”‚
â”‚             â”‚      â”‚  Verify  â”‚
â”‚ Key: user:  â”‚      â”‚          â”‚
â”‚ token:{uid} â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚             â”‚
â”‚ Value:      â”‚
â”‚ {current_   â”‚
â”‚  token}     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ ¡éªŒé€»è¾‘:
if Request.Token == Redis.Token:
    âœ… é€šè¿‡ (æœ€æ–° Token)
else:
    âŒ æ‹’ç» (æ—§ Token,å·²è¢«è¸¢ä¸‹çº¿)
```

**å·¥ä½œæµç¨‹:**

```
ã€è®¾å¤‡ A ç™»å½•ã€‘
1. ç”¨æˆ·åœ¨è®¾å¤‡ A è¾“å…¥è´¦å·å¯†ç 
2. æœåŠ¡å™¨éªŒè¯é€šè¿‡,ç”Ÿæˆ Token_A
3. Redis.SET("user:token:1001", Token_A, TTL=10min)
4. è¿”å› Token_A ç»™è®¾å¤‡ A

ã€è®¾å¤‡ A è®¿é—®æ¥å£ã€‘
5. è®¾å¤‡ A æºå¸¦ Token_A è¯·æ±‚æ¥å£
6. ä¸­é—´ä»¶éªŒè¯: Token_A == Redis.GET("user:token:1001")
7. âœ… é€šè¿‡,æ­£å¸¸è¿”å›æ•°æ®

ã€è®¾å¤‡ B ç™»å½• (è¸¢æ‰è®¾å¤‡ A)ã€‘
8. ç”¨æˆ·åœ¨è®¾å¤‡ B è¾“å…¥è´¦å·å¯†ç 
9. æœåŠ¡å™¨éªŒè¯é€šè¿‡,ç”Ÿæˆ Token_B
10. Redis.SET("user:token:1001", Token_B, TTL=10min)  // è¦†ç›– Token_A
11. è¿”å› Token_B ç»™è®¾å¤‡ B

ã€è®¾å¤‡ A å†æ¬¡è®¿é—®æ¥å£ (è¢«è¸¢)ã€‘
12. è®¾å¤‡ A æºå¸¦ Token_A è¯·æ±‚æ¥å£
13. ä¸­é—´ä»¶éªŒè¯: Token_A != Redis.GET("user:token:1001")  // ä¸ä¸€è‡´!
14. âŒ æ‹’ç»,è¿”å› "è´¦å·å·²åœ¨å…¶ä»–è®¾å¤‡ç™»å½•"
15. è®¾å¤‡ A è·³è½¬ç™»å½•é¡µ
```

### 1.3 ä¸ºä»€ä¹ˆä¸åœ¨ JWT Claims ä¸­åŠ è®¾å¤‡ID?

**é”™è¯¯æ–¹æ¡ˆ (âŒ):**

```go
type UserClaims struct {
    UserID   int64  `json:"user_id"`
    DeviceID string `json:"device_id"`  // è®¾å¤‡æ ‡è¯†
    jwt.RegisteredClaims
}

// ä¸­é—´ä»¶ä¸­æ£€æŸ¥
if claims.DeviceID != currentDeviceID {
    return errors.New("è®¾å¤‡ä¸åŒ¹é…")
}
```

**é—®é¢˜:**

1. **æ— æ³•è¸¢äºº**: æ—§è®¾å¤‡çš„ Token ä¾ç„¶æœ‰æ•ˆ,åªæ˜¯åœ¨"å¦ä¸€å°è®¾å¤‡"ä¸Šæ— æ³•ä½¿ç”¨ã€‚
2. **ç»•è¿‡é£é™©**: æ”»å‡»è€…çªƒå– Token å,åªè¦ä¼ªé€ è®¾å¤‡IDå°±èƒ½ä½¿ç”¨ã€‚
3. **ç®¡ç†å¤æ‚**: æ— æ³•å®ç°"æŸ¥çœ‹æ‰€æœ‰åœ¨çº¿è®¾å¤‡"ã€"è¸¢æ‰æŒ‡å®šè®¾å¤‡"ç­‰åŠŸèƒ½ã€‚

**æ­£ç¡®æ–¹æ¡ˆ (âœ…): Redis çŠ¶æ€ç®¡ç†**

- Redis æ˜¯å”¯ä¸€çš„çœŸç›¸æ¥æº,Token æ— éœ€æ„ŸçŸ¥è®¾å¤‡ä¿¡æ¯ã€‚
- æœåŠ¡å™¨å®Œå…¨æ§åˆ¶ Token çš„æœ‰æ•ˆæ€§,å®‰å…¨å¯æ§ã€‚

---

## 2. Redis å±‚å®ç°

### 2.1 Key è®¾è®¡æ¨¡å¼

Redis Key çš„è®¾è®¡ç›´æ¥å½±å“æ€§èƒ½å’Œå¯ç»´æŠ¤æ€§ã€‚

#### æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | Key æ ¼å¼ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|---------|------|------|
| âŒ å¹³é“º | `user_token_1001` | ç®€å• | éš¾ä»¥æ‰¹é‡æ“ä½œ,å‘½åç©ºé—´æ±¡æŸ“ |
| âœ… åˆ†å±‚ | `bluebell:user:token:1001` | æ¸…æ™°åˆ†ç»„,æ”¯æŒé€šé…æŸ¥è¯¢ | Key ç¨é•¿ |
| âœ… Hash | `bluebell:user:1001` (Hash) | èŠ‚çœå†…å­˜ | æ— æ³•å•ç‹¬è®¾ç½®è¿‡æœŸæ—¶é—´ |

**æˆ‘ä»¬çš„é€‰æ‹©: åˆ†å±‚ String**

```
Key: bluebell:user:access_token:{userID}
Value: {access_token}
TTL: 10 åˆ†é’Ÿ (ä¸ Access Token è¿‡æœŸæ—¶é—´ä¸€è‡´)

Key: bluebell:user:refresh_token:{userID}
Value: {refresh_token}
TTL: 30 å¤© (ä¸ Refresh Token è¿‡æœŸæ—¶é—´ä¸€è‡´)
```

**ä¸ºä»€ä¹ˆç”¨ String è€Œä¸æ˜¯ Hash?**

- String å¯ä»¥å•ç‹¬è®¾ç½® TTL,è‡ªåŠ¨è¿‡æœŸã€‚
- Hash éœ€è¦æ‰‹åŠ¨æ¸…ç†,å®¹æ˜“é—æ¼ã€‚
- æ€§èƒ½å·®å¼‚å¯å¿½ç•¥(å•ç”¨æˆ·åªæœ‰ 2 ä¸ª Key)ã€‚

### 2.2 å®šä¹‰ Key å¸¸é‡

åœ¨ `dao/redis/keys.go` ä¸­:

```go
package redis

// Redis Key å‰ç¼€å¸¸é‡
const (
	KeyPrefix = "bluebell:"  // é¡¹ç›®å‰ç¼€,é¿å… Key å†²çª

	// ç”¨æˆ·ç›¸å…³
	KeyUserAccessToken  = "user:access_token:"   // ç”¨æˆ· Access Token
	KeyUserRefreshToken = "user:refresh_token:"  // ç”¨æˆ· Refresh Token

	// è®¾å¤‡ç›¸å…³ (æ‰©å±•åŠŸèƒ½)
	KeyUserDevices = "user:devices:"  // ç”¨æˆ·è®¾å¤‡åˆ—è¡¨ (Hash)
)

// getRedisKey ç”Ÿæˆå®Œæ•´çš„ Redis Key
// ä¸ºä»€ä¹ˆ: ç»Ÿä¸€æ·»åŠ å‰ç¼€,é¿å…ç¡¬ç¼–ç 
func getRedisKey(key string) string {
	return KeyPrefix + key
}
```

**è®¾è®¡åŸåˆ™:**

1. **é¡¹ç›®å‰ç¼€**: é¿å…ä¸å…¶ä»–é¡¹ç›®çš„ Key å†²çª(ç‰¹åˆ«æ˜¯å…±äº« Redis å®ä¾‹æ—¶)ã€‚
2. **åˆ†å±‚å‘½å**: `æ¨¡å—:å­æ¨¡å—:å…·ä½“åŠŸèƒ½`,è¯­ä¹‰æ¸…æ™°ã€‚
3. **ç»Ÿä¸€å‡½æ•°**: `getRedisKey()` ç¡®ä¿æ‰€æœ‰ Key éƒ½ç»è¿‡å‰ç¼€å¤„ç†ã€‚

### 2.3 å­˜å– Token æ–¹æ³•

åœ¨ `dao/redis/user.go` ä¸­:

```go
package redis

import (
	"context"
	"fmt"
	"time"
)

// SetUserToken å°† Access Token å’Œ Refresh Token å­˜å…¥ Redis
// ä¸ºä»€ä¹ˆç”¨ Pipeline:
//   - å‡å°‘ç½‘ç»œå¾€è¿” (2 ä¸ª SET å‘½ä»¤ä¸€æ¬¡æ€§å‘é€)
//   - æ¥è¿‘åŸå­æ€§ (è™½ç„¶ä¸æ˜¯çœŸæ­£çš„åŸå­,ä½†ä¸¤ä¸ªå‘½ä»¤ä¼šè¿ç»­æ‰§è¡Œ)
func SetUserToken(userID int64, aToken, rToken string, aExp, rExp time.Duration) error {
	pipe := rdb.Pipeline()

	// 1. å­˜å‚¨ Access Token
	// Key: bluebell:user:access_token:1001
	// Value: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
	// TTL: 10 åˆ†é’Ÿ (è‡ªåŠ¨è¿‡æœŸ)
	keyAT := getRedisKey(KeyUserAccessToken + fmt.Sprint(userID))
	pipe.Set(ctx, keyAT, aToken, aExp)

	// 2. å­˜å‚¨ Refresh Token
	// Key: bluebell:user:refresh_token:1001
	// Value: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
	// TTL: 30 å¤© (è‡ªåŠ¨è¿‡æœŸ)
	keyRT := getRedisKey(KeyUserRefreshToken + fmt.Sprint(userID))
	pipe.Set(ctx, keyRT, rToken, rExp)

	// æ‰§è¡Œ Pipeline
	_, err := pipe.Exec(ctx)
	return err
}

// GetUserAccessToken è·å–å½“å‰æœ‰æ•ˆçš„ Access Token
// ä¸ºä»€ä¹ˆ: ä¸­é—´ä»¶éœ€è¦è·å– Redis ä¸­çš„ Token ä¸è¯·æ±‚ä¸­çš„ Token å¯¹æ¯”
func GetUserAccessToken(userID int64) (string, error) {
	key := getRedisKey(KeyUserAccessToken + fmt.Sprint(userID))
	return rdb.Get(ctx, key).Result()
}

// GetUserRefreshToken è·å–å½“å‰æœ‰æ•ˆçš„ Refresh Token
// ä¸ºä»€ä¹ˆ: åˆ·æ–° Token æ—¶éœ€è¦éªŒè¯ Refresh Token æ˜¯å¦ä»æœ‰æ•ˆ
func GetUserRefreshToken(userID int64) (string, error) {
	key := getRedisKey(KeyUserRefreshToken + fmt.Sprint(userID))
	return rdb.Get(ctx, key).Result()
}

// DeleteUserToken åˆ é™¤ç”¨æˆ·çš„ Token (ç”¨äºç™»å‡º/ä¿®æ”¹å¯†ç )
// ä¸ºä»€ä¹ˆ: å¼ºåˆ¶ç”¨æˆ·é‡æ–°ç™»å½•æ—¶,éœ€è¦åˆ é™¤ Redis ä¸­çš„ Token
func DeleteUserToken(userID int64) error {
	pipe := rdb.Pipeline()

	keyAT := getRedisKey(KeyUserAccessToken + fmt.Sprint(userID))
	pipe.Del(ctx, keyAT)

	keyRT := getRedisKey(KeyUserRefreshToken + fmt.Sprint(userID))
	pipe.Del(ctx, keyRT)

	_, err := pipe.Exec(ctx)
	return err
}
```

**ä¸ºä»€ä¹ˆç”¨ Pipeline?**

```go
// âŒ ä¸ä½¿ç”¨ Pipeline (2 æ¬¡ç½‘ç»œå¾€è¿”)
rdb.Set(ctx, keyAT, aToken, aExp)  // RTT 1
rdb.Set(ctx, keyRT, rToken, rExp)  // RTT 2

// âœ… ä½¿ç”¨ Pipeline (1 æ¬¡ç½‘ç»œå¾€è¿”)
pipe := rdb.Pipeline()
pipe.Set(ctx, keyAT, aToken, aExp)
pipe.Set(ctx, keyRT, rToken, rExp)
pipe.Exec(ctx)  // ä¸€æ¬¡æ€§å‘é€
```

**æ€§èƒ½å¯¹æ¯”:**

- ä¸ä½¿ç”¨ Pipeline: 2ms (ç½‘ç»œå»¶è¿Ÿ) Ã— 2 = 4ms
- ä½¿ç”¨ Pipeline: 2ms (ç½‘ç»œå»¶è¿Ÿ) Ã— 1 = 2ms
- **æ€§èƒ½æå‡: 50%**

---

## 3. ä¸šåŠ¡é€»è¾‘å±‚é›†æˆ

### 3.1 ç™»å½•é€»è¾‘æ”¹é€ 

åœ¨ `logic/user.go` ä¸­,ç”Ÿæˆ Token åç«‹å³å­˜å…¥ Redis:

```go
package logic

import (
	"bluebell/dao/mysql"
	"bluebell/dao/redis"
	"bluebell/models"
	"bluebell/pkg/jwt"
)

// Login å¤„ç†ç”¨æˆ·ç™»å½•
func Login(p *models.ParamLogin) (string, string, error) {
	user := &models.User{
		Username: p.Username,
		Password: p.Password,
	}

	// 1. éªŒè¯ç”¨æˆ·åå’Œå¯†ç  (DAO å±‚)
	if err := mysql.CheckLogin(user); err != nil {
		return "", "", err
	}

	// 2. ç”Ÿæˆ JWT Token
	aToken, rToken, err := jwt.GenToken(user.UserID, user.Username)
	if err != nil {
		return "", "", err
	}

	// 3. ã€æ ¸å¿ƒã€‘å­˜å…¥ Redis,å®ç°äº’è¸¢
	// ä¸ºä»€ä¹ˆ: è¿™ä¼šè¦†ç›–æ‰è¯¥ç”¨æˆ·ä¹‹å‰åœ¨ Redis ä¸­çš„ Token
	//         æ—§è®¾å¤‡çš„ Token ä¼šåœ¨ä¸­é—´ä»¶ä¸­è¢«æ‹’ç» (ä¸ Redis ä¸åŒ¹é…)
	err = redis.SetUserToken(
		user.UserID,
		aToken,
		rToken,
		jwt.AccessTokenExpireDuration,
		jwt.RefreshTokenExpireDuration,
	)
	if err != nil {
		return "", "", err
	}

	return aToken, rToken, nil
}
```

**é€»è¾‘æµç¨‹:**

```
ç”¨æˆ·ç™»å½•
    â†“
1. mysql.CheckLogin() â”€â”€ éªŒè¯å¯†ç 
    â”œâ”€ ç”¨æˆ·ä¸å­˜åœ¨ â†’ è¿”å›é”™è¯¯
    â”œâ”€ å¯†ç é”™è¯¯ â†’ è¿”å›é”™è¯¯
    â””â”€ éªŒè¯é€šè¿‡ â†’ ç»§ç»­
    â†“
2. jwt.GenToken() â”€â”€â”€â”€â”€  ç”ŸæˆåŒ Token
    â”œâ”€ Access Token (10 åˆ†é’Ÿ)
    â””â”€ Refresh Token (30 å¤©)
    â†“
3. redis.SetUserToken() â”€ å­˜å‚¨åˆ° Redis
    â”œâ”€ SET user:access_token:{id} = {aToken}
    â””â”€ SET user:refresh_token:{id} = {rToken}
    â†“
è¿”å›åŒ Token ç»™å®¢æˆ·ç«¯
```

### 3.2 åˆ·æ–°é€»è¾‘æ”¹é€ 

åœ¨ `logic/user.go` ä¸­,åˆ·æ–° Token åä¹Ÿå¿…é¡»æ›´æ–° Redis:

```go
// RefreshToken åˆ·æ–° Token
func RefreshToken(aToken, rToken string) (newAToken, newRToken string, err error) {
	// 1. éªŒè¯ Refresh Token å¹¶è·å–ç”¨æˆ·ä¿¡æ¯
	user, err := jwt.ValidateRefreshToken(rToken)
	if err != nil {
		return "", "", err
	}

	// 2. ç”Ÿæˆæ–° Token
	newAToken, newRToken, err = jwt.GenToken(user.UserID, user.Username)
	if err != nil {
		return "", "", err
	}

	// 3. ã€å…³é”®ã€‘æ›´æ–° Redis çŠ¶æ€
	// ä¸ºä»€ä¹ˆ: å¦‚æœä¸æ›´æ–°,æ–°ç”Ÿæˆçš„ Token å°†æ— æ³•é€šè¿‡ä¸­é—´ä»¶æ ¡éªŒ
	//         å› ä¸ºä¸­é—´ä»¶ä¼šå¯¹æ¯”è¯·æ±‚ä¸­çš„ Token ä¸ Redis ä¸­çš„ Token
	err = redis.SetUserToken(
		user.UserID,
		newAToken,
		newRToken,
		jwt.AccessTokenExpireDuration,
		jwt.RefreshTokenExpireDuration,
	)
	if err != nil {
		return "", "", err
	}

	return newAToken, newRToken, nil
}
```

**ä¸ºä»€ä¹ˆåˆ·æ–°ä¹Ÿè¦æ›´æ–° Redis?**

```
åœºæ™¯: ç”¨æˆ·çš„ Access Token è¿‡æœŸ,å‰ç«¯è‡ªåŠ¨åˆ·æ–°

æ—§ Access Token: Token_A (è¿‡æœŸ)
æ—§ Refresh Token: RToken_A

å‰ç«¯è°ƒç”¨åˆ·æ–°æ¥å£:
  â†“
æœåŠ¡å™¨ç”Ÿæˆæ–° Token:
  æ–° Access Token: Token_B
  æ–° Refresh Token: RToken_B
  â†“
å¦‚æœä¸æ›´æ–° Redis:
  Redis ä¸­ä»æ˜¯ Token_A
  â†“
å‰ç«¯ç”¨ Token_B è¯·æ±‚æ¥å£:
  ä¸­é—´ä»¶å¯¹æ¯”: Token_B != Redis(Token_A)
  â†“
âŒ æ‹’ç»! (æ˜æ˜æ˜¯åˆæ³•çš„æ–° Token,å´è¢«æ‹’ç»)

å¦‚æœæ›´æ–° Redis:
  Redis æ›´æ–°ä¸º Token_B
  â†“
å‰ç«¯ç”¨ Token_B è¯·æ±‚æ¥å£:
  ä¸­é—´ä»¶å¯¹æ¯”: Token_B == Redis(Token_B)
  â†“
âœ… é€šè¿‡!
```

### 3.3 ç™»å‡ºé€»è¾‘å®ç°

```go
// Logout ç”¨æˆ·ç™»å‡º
func Logout(userID int64) error {
	// åˆ é™¤ Redis ä¸­çš„ Token
	// ä¸ºä»€ä¹ˆ: ç«‹å³è®©æ‰€æœ‰è®¾å¤‡çš„ Token å¤±æ•ˆ,å¼ºåˆ¶é‡æ–°ç™»å½•
	err := redis.DeleteUserToken(userID)
	if err != nil {
		zap.L().Error("delete user token failed",
			zap.Int64("user_id", userID),
			zap.Error(err))
		return err
	}

	return nil
}
```

```go
// Controller
func LogoutHandler(c *gin.Context) {
	// è·å–å½“å‰ç”¨æˆ· ID
	userID, err := GetCurrentUser(c)
	if err != nil {
		ResponseError(c, CodeNeedLogin)
		return
	}

	// è°ƒç”¨ä¸šåŠ¡é€»è¾‘
	err = logic.Logout(userID)
	if err != nil {
		ResponseError(c, CodeServerBusy)
		return
	}

	ResponseSuccess(c, nil)
}
```

---

## 4. ä¸­é—´ä»¶å®ç°äº’è¸¢æ ¡éªŒ

åœ¨ `middlewares/auth.go` ä¸­,è¿™æ˜¯å®ç°"è¸¢äºº"é€»è¾‘çš„æ ¸å¿ƒæ‰§è¡Œç‚¹:

```go
package middlewares

import (
	"bluebell/controller"
	"bluebell/dao/redis"
	"bluebell/pkg/jwt"
	"strings"

	"github.com/gin-gonic/gin"
)

// JWTAuthMiddleware åŸºäºJWTçš„è®¤è¯ä¸­é—´ä»¶
func JWTAuthMiddleware() func(c *gin.Context) {
	return func(c *gin.Context) {
		// 1. è·å– Authorization header
		authHeader := c.Request.Header.Get("Authorization")
		if authHeader == "" {
			controller.ResponseError(c, controller.CodeNeedLogin)
			c.Abort()
			return
		}

		// 2. è§£ææ ¼å¼ "Bearer <token>"
		parts := strings.SplitN(authHeader, " ", 2)
		if !(len(parts) == 2 && parts[0] == "Bearer") {
			controller.ResponseError(c, controller.CodeInvalidToken)
			c.Abort()
			return
		}
		clientToken := parts[1]  // å®¢æˆ·ç«¯æºå¸¦çš„ Token

		// 3. JWT ç­¾åéªŒè¯
		// ParseToken å†…éƒ¨ä¼š:
		//   - éªŒè¯ç­¾åæ˜¯å¦æ­£ç¡®
		//   - æ£€æŸ¥ Token æ˜¯å¦è¿‡æœŸ
		//   - è¿”å› UserClaims (åŒ…å« UserID)
		mc, err := jwt.ParseToken(clientToken)
		if err != nil {
			controller.ResponseError(c, controller.CodeInvalidToken)
			c.Abort()
			return
		}

		// 4. ã€æ ¸å¿ƒã€‘Redis äº’è¸¢æ ¡éªŒ
		// ä» Redis è·å–è¯¥ç”¨æˆ·å½“å‰æœ‰æ•ˆçš„ Token
		serverToken, err := redis.GetUserAccessToken(mc.UserID)
		if err != nil {
			// Redis ä¸­ä¸å­˜åœ¨è¯¥ Key
			// å¯èƒ½åŸå› :
			//   1. Key å·²è¿‡æœŸ (TTL=10åˆ†é’Ÿ)
			//   2. ç”¨æˆ·ç™»å‡º (æ‰‹åŠ¨åˆ é™¤)
			//   3. Redis æ•…éšœ
			controller.ResponseError(c, controller.CodeNeedLogin)
			c.Abort()
			return
		}

		// 5. æ¯”è¾ƒå®¢æˆ·ç«¯ Token ä¸æœåŠ¡ç«¯ Token
		if clientToken != serverToken {
			// ä¸ä¸€è‡´,è¯´æ˜ Redis ä¸­å­˜çš„æ˜¯æ›´æ–°çš„ Token
			// å½“å‰è¯·æ±‚æºå¸¦çš„æ˜¯æ—§ Token,å·²å¤±æ•ˆ
			controller.ResponseErrorWithMsg(c, controller.CodeInvalidToken, "è´¦å·å·²åœ¨å…¶ä»–è®¾å¤‡ç™»å½•")
			c.Abort()
			return
		}

		// 6. æ ¡éªŒé€šè¿‡,æ³¨å…¥ UserID åˆ°ä¸Šä¸‹æ–‡
		// åç»­çš„ Controller å¯ä»¥é€šè¿‡ c.Get(controller.CtxUserIDKey) è·å–ç”¨æˆ· ID
		c.Set(controller.CtxUserIDKey, mc.UserID)

		c.Next()  // æ”¾è¡Œ
	}
}
```

**æ ¡éªŒæµç¨‹å›¾:**

```
HTTP è¯·æ±‚åˆ°è¾¾
    â†“
æå– Authorization Header
    â”œâ”€ æ²¡æœ‰ â†’ 401 éœ€è¦ç™»å½•
    â””â”€ æœ‰ â†’ ç»§ç»­
    â†“
è§£æ "Bearer <token>"
    â”œâ”€ æ ¼å¼é”™è¯¯ â†’ 401 Token æ ¼å¼é”™è¯¯
    â””â”€ æ ¼å¼æ­£ç¡® â†’ clientToken
    â†“
JWT ç­¾åéªŒè¯
    â”œâ”€ ç­¾åé”™è¯¯ â†’ 401 Token æ— æ•ˆ
    â”œâ”€ Token è¿‡æœŸ â†’ 401 Token æ— æ•ˆ
    â””â”€ éªŒè¯é€šè¿‡ â†’ UserClaims (UserID)
    â†“
æŸ¥è¯¢ Redis
    â”œâ”€ Key ä¸å­˜åœ¨ â†’ 401 éœ€è¦ç™»å½• (Token å·²å¤±æ•ˆ)
    â””â”€ æŸ¥è¯¢æˆåŠŸ â†’ serverToken
    â†“
å¯¹æ¯” Token
    â”œâ”€ clientToken != serverToken â†’ 401 è´¦å·å·²åœ¨å…¶ä»–è®¾å¤‡ç™»å½•
    â””â”€ clientToken == serverToken â†’ âœ… é€šè¿‡
    â†“
æ³¨å…¥ UserID åˆ°ä¸Šä¸‹æ–‡
    â†“
æ”¾è¡Œ (c.Next)
    â†“
ä¸šåŠ¡ Handler æ‰§è¡Œ
```

---

## 5. å®Œæ•´åœºæ™¯æ¨æ¼”

### 5.1 åœºæ™¯ä¸€: æ­£å¸¸ç™»å½•å’Œè®¿é—®

```
ã€æ—¶é—´çº¿ã€‘
T0: ç”¨æˆ·åœ¨æ‰‹æœºä¸Šç™»å½•

1. å®¢æˆ·ç«¯: POST /login {username: "lay", password: "123456"}
2. æœåŠ¡å™¨:
   - éªŒè¯å¯†ç  âœ…
   - ç”Ÿæˆ Token_Phone
   - Redis.SET("bluebell:user:access_token:1001", Token_Phone, 10min)
   - è¿”å› Token_Phone

T1: ç”¨æˆ·è®¿é—®å¸–å­åˆ—è¡¨ (ç¬¬ 1 åˆ†é’Ÿ)

3. å®¢æˆ·ç«¯: GET /posts, Header: Bearer Token_Phone
4. ä¸­é—´ä»¶:
   - JWT ç­¾åéªŒè¯ âœ…
   - Redis.GET("bluebell:user:access_token:1001") = Token_Phone
   - Token_Phone == Token_Phone âœ…
   - æ”¾è¡Œ
5. æœåŠ¡å™¨: è¿”å›å¸–å­åˆ—è¡¨

T5: ç”¨æˆ·ç»§ç»­è®¿é—® (ç¬¬ 5 åˆ†é’Ÿ)

6. å®¢æˆ·ç«¯: GET /community, Header: Bearer Token_Phone
7. ä¸­é—´ä»¶: åŒä¸Š,éªŒè¯é€šè¿‡ âœ…
8. æœåŠ¡å™¨: è¿”å›ç¤¾åŒºåˆ—è¡¨
```

### 5.2 åœºæ™¯äºŒ: äº’è¸¢ä¸‹çº¿

```
ã€æ—¶é—´çº¿ã€‘
T0: ç”¨æˆ·åœ¨æ‰‹æœºä¸Šç™»å½• (ç»§ç»­ä¸Šé¢çš„åœºæ™¯)
Redis: Token_Phone

T6: ç”¨æˆ·åœ¨ç”µè„‘ä¸Šç™»å½• (ç¬¬ 6 åˆ†é’Ÿ)

1. å®¢æˆ·ç«¯ (PC): POST /login {username: "lay", password: "123456"}
2. æœåŠ¡å™¨:
   - éªŒè¯å¯†ç  âœ…
   - ç”Ÿæˆ Token_PC
   - Redis.SET("bluebell:user:access_token:1001", Token_PC, 10min)  // è¦†ç›–!
   - è¿”å› Token_PC

Redis çŠ¶æ€å˜åŒ–:
  æ—§å€¼: Token_Phone
  æ–°å€¼: Token_PC  (Token_Phone è¢«è¦†ç›–)

T7: ç”¨æˆ·ç»§ç»­ç”¨æ‰‹æœºè®¿é—® (ç¬¬ 7 åˆ†é’Ÿ)

3. å®¢æˆ·ç«¯ (Phone): GET /posts, Header: Bearer Token_Phone
4. ä¸­é—´ä»¶:
   - JWT ç­¾åéªŒè¯ âœ… (Token_Phone æœªè¿‡æœŸ,ç­¾åæœ‰æ•ˆ)
   - Redis.GET("bluebell:user:access_token:1001") = Token_PC
   - Token_Phone != Token_PC âŒ
   - æ‹’ç»!
5. æœåŠ¡å™¨: è¿”å› 401 "è´¦å·å·²åœ¨å…¶ä»–è®¾å¤‡ç™»å½•"
6. å®¢æˆ·ç«¯ (Phone): æ”¶åˆ° 401,è·³è½¬ç™»å½•é¡µ,æ˜¾ç¤ºæç¤ºä¿¡æ¯

T8: ç”¨æˆ·ç”¨ç”µè„‘è®¿é—® (ç¬¬ 8 åˆ†é’Ÿ)

7. å®¢æˆ·ç«¯ (PC): GET /posts, Header: Bearer Token_PC
8. ä¸­é—´ä»¶:
   - JWT ç­¾åéªŒè¯ âœ…
   - Redis.GET("bluebell:user:access_token:1001") = Token_PC
   - Token_PC == Token_PC âœ…
   - æ”¾è¡Œ
9. æœåŠ¡å™¨: è¿”å›å¸–å­åˆ—è¡¨
```

### 5.3 åœºæ™¯ä¸‰: ä¿®æ”¹å¯†ç å¼ºåˆ¶ä¸‹çº¿

```
ã€æ—¶é—´çº¿ã€‘
T0: ç”¨æˆ·åœ¨å¤šä¸ªè®¾å¤‡ç™»å½•
  - æ‰‹æœº: Token_Phone
  - ç”µè„‘: Token_PC (æœ€æ–°)
  - å¹³æ¿: Token_Pad (æ—§,å·²è¢«è¸¢)

Redis: Token_PC

T1: ç”¨æˆ·åœ¨ç½‘é¡µä¸Šä¿®æ”¹å¯†ç 

1. å®¢æˆ·ç«¯ (PC): POST /change_password
   {
     "old_password": "123456",
     "new_password": "newpass"
   }
2. æœåŠ¡å™¨:
   - éªŒè¯æ—§å¯†ç  âœ…
   - æ›´æ–°å¯†ç åˆ°æ•°æ®åº“
   - ã€å…³é”®ã€‘redis.DeleteUserToken(userID)  // åˆ é™¤ Redis ä¸­çš„ Token
3. è¿”å›æˆåŠŸ

Redis çŠ¶æ€å˜åŒ–:
  æ—§å€¼: Token_PC
  æ–°å€¼: (Key è¢«åˆ é™¤)

T2: ç”¨æˆ·åœ¨ä»»æ„è®¾å¤‡è®¿é—®æ¥å£

4. å®¢æˆ·ç«¯: GET /posts, Header: Bearer Token_PC (æˆ–ä»»ä½•æ—§ Token)
5. ä¸­é—´ä»¶:
   - JWT ç­¾åéªŒè¯ âœ… (Token æœªè¿‡æœŸ)
   - Redis.GET("bluebell:user:access_token:1001") = nil (Key ä¸å­˜åœ¨)
   - âŒ æ‹’ç»!
6. æœåŠ¡å™¨: è¿”å› 401 "éœ€è¦ç™»å½•"
7. å®¢æˆ·ç«¯: è·³è½¬ç™»å½•é¡µ

ç”¨æˆ·å¿…é¡»é‡æ–°ç™»å½•:
8. è¾“å…¥æ–°å¯†ç 
9. ç”Ÿæˆæ–° Token
10. å†™å…¥ Redis
11. æ­£å¸¸ä½¿ç”¨
```

---

## 6. å¤šè®¾å¤‡ç®¡ç†(æ‰©å±•åŠŸèƒ½)

ç›®å‰çš„æ–¹æ¡ˆåªæ”¯æŒ"äº’è¸¢æ¨¡å¼"(å•è®¾å¤‡ç™»å½•)ã€‚å¦‚æœè¦æ”¯æŒå¤šè®¾å¤‡å¹¶å­˜,éœ€è¦æ”¹è¿› Redis Key è®¾è®¡ã€‚

### 6.1 å¤šè®¾å¤‡å…±å­˜æ–¹æ¡ˆ

**æ”¹è¿›çš„ Redis Key è®¾è®¡:**

```
åŸæ–¹æ¡ˆ (å•è®¾å¤‡):
  Key: bluebell:user:access_token:{userID}
  Value: {token}

æ”¹è¿›æ–¹æ¡ˆ (å¤šè®¾å¤‡):
  Key: bluebell:user:access_token:{userID}:{deviceID}
  Value: {token}
```

**è®¾å¤‡ID ç”Ÿæˆ (å‰ç«¯):**

```javascript
// æµè§ˆå™¨ç¯å¢ƒ
const deviceID = localStorage.getItem('device_id') || generateDeviceID()

function generateDeviceID() {
  const id = `${navigator.userAgent}_${screen.width}x${screen.height}_${Date.now()}`
  const hash = SHA256(id)  // ç®€åŒ–ä¸ºå“ˆå¸Œå€¼
  localStorage.setItem('device_id', hash)
  return hash
}
```

**åç«¯æ”¹é€ :**

```go
// ç™»å½•æ—¶ä¼ å…¥ deviceID
type ParamLogin struct {
    Username string `json:"username" binding:"required"`
    Password string `json:"password" binding:"required"`
    DeviceID string `json:"device_id" binding:"required"`  // æ–°å¢
}

// Redis å­˜å‚¨æ”¹é€ 
func SetUserTokenByDevice(userID int64, deviceID string, aToken, rToken string, aExp, rExp time.Duration) error {
    pipe := rdb.Pipeline()

    keyAT := fmt.Sprintf("%suser:access_token:%d:%s", KeyPrefix, userID, deviceID)
    pipe.Set(ctx, keyAT, aToken, aExp)

    keyRT := fmt.Sprintf("%suser:refresh_token:%d:%s", KeyPrefix, userID, deviceID)
    pipe.Set(ctx, keyRT, rToken, rExp)

    _, err := pipe.Exec(ctx)
    return err
}
```

**è®¾å¤‡åˆ—è¡¨æŸ¥è¯¢:**

```go
// æŸ¥è¯¢ç”¨æˆ·æ‰€æœ‰åœ¨çº¿è®¾å¤‡
func GetUserDevices(userID int64) ([]string, error) {
    pattern := fmt.Sprintf("%suser:access_token:%d:*", KeyPrefix, userID)
    keys, err := rdb.Keys(ctx, pattern).Result()
    if err != nil {
        return nil, err
    }

    devices := make([]string, 0, len(keys))
    for _, key := range keys {
        // æå– deviceID
        parts := strings.Split(key, ":")
        deviceID := parts[len(parts)-1]
        devices = append(devices, deviceID)
    }

    return devices, nil
}
```

### 6.2 é™åˆ¶è®¾å¤‡æ•°é‡

```go
// æœ€å¤šå…è®¸ 3 ä¸ªè®¾å¤‡åŒæ—¶åœ¨çº¿
func Login(p *models.ParamLogin) (string, string, error) {
    // 1. éªŒè¯å¯†ç ...

    // 2. æ£€æŸ¥è®¾å¤‡æ•°é‡
    devices, _ := redis.GetUserDevices(user.UserID)
    if len(devices) >= 3 {
        // è¸¢æ‰æœ€æ—©ç™»å½•çš„è®¾å¤‡
        oldestDevice := devices[0]
        redis.DeleteUserTokenByDevice(user.UserID, oldestDevice)
    }

    // 3. ç”Ÿæˆæ–° Token å¹¶å­˜å‚¨
    // ...
}
```

---

## 7. å®‰å…¨æ€§åˆ†æ

### 7.1 å¹¶å‘ç™»å½•é—®é¢˜

**åœºæ™¯:** ç”¨æˆ·åœ¨æçŸ­æ—¶é—´å†…(æ¯«ç§’çº§)åœ¨ä¸¤ä¸ªè®¾å¤‡ä¸ŠåŒæ—¶ç™»å½•ã€‚

```
T0: è®¾å¤‡ A å’Œè®¾å¤‡ B åŒæ—¶å‘èµ·ç™»å½•è¯·æ±‚

è®¾å¤‡ A:
  1. éªŒè¯å¯†ç  âœ…
  2. ç”Ÿæˆ Token_A
  3. Redis.SET("user:token:1001", Token_A)
  4. è¿”å› Token_A

è®¾å¤‡ B:
  1. éªŒè¯å¯†ç  âœ…
  2. ç”Ÿæˆ Token_B
  3. Redis.SET("user:token:1001", Token_B)  // è¦†ç›– Token_A
  4. è¿”å› Token_B

ç»“æœ: Token_A ç«‹å³å¤±æ•ˆ,è®¾å¤‡ A è¢«è¸¢ä¸‹çº¿
```

**è¿™æ˜¯é¢„æœŸè¡Œä¸ºè¿˜æ˜¯ Bug?**

- **é¢„æœŸè¡Œä¸º**: äº’è¸¢æ¨¡å¼ä¸‹,æœ€åç™»å½•çš„è®¾å¤‡ç”Ÿæ•ˆã€‚
- **å¦‚æœä¸å¸Œæœ›äº’è¸¢**: æ”¹ç”¨å¤šè®¾å¤‡å…±å­˜æ–¹æ¡ˆã€‚

### 7.2 Redis æ•…éšœé™çº§

**é—®é¢˜:** å¦‚æœ Redis å®•æœº,æ‰€æœ‰ç”¨æˆ·éƒ½æ— æ³•è®¿é—®æ¥å£ã€‚

**é™çº§æ–¹æ¡ˆ:**

```go
func JWTAuthMiddleware() func(c *gin.Context) {
    return func(c *gin.Context) {
        // ... JWT ç­¾åéªŒè¯ ...

        // Redis æ ¡éªŒ
        serverToken, err := redis.GetUserAccessToken(mc.UserID)
        if err != nil {
            // åˆ¤æ–­æ˜¯å¦æ˜¯ Redis è¿æ¥é”™è¯¯
            if errors.Is(err, redis.ErrRedisDown) {
                // é™çº§: è·³è¿‡ Redis éªŒè¯,ä»…ä¾èµ– JWT ç­¾å
                zap.L().Warn("Redis is down, fallback to JWT-only validation")
                c.Set(controller.CtxUserIDKey, mc.UserID)
                c.Next()
                return
            }

            // å…¶ä»–é”™è¯¯ (å¦‚ Key ä¸å­˜åœ¨),æ­£å¸¸æ‹’ç»
            controller.ResponseError(c, controller.CodeNeedLogin)
            c.Abort()
            return
        }

        // æ­£å¸¸æ ¡éªŒ
        if clientToken != serverToken {
            controller.ResponseErrorWithMsg(c, controller.CodeInvalidToken, "è´¦å·å·²åœ¨å…¶ä»–è®¾å¤‡ç™»å½•")
            c.Abort()
            return
        }

        c.Set(controller.CtxUserIDKey, mc.UserID)
        c.Next()
    }
}
```

**æƒè¡¡:**

- âœ… é™çº§åæœåŠ¡å¯ç”¨æ€§æå‡
- âŒ å¤±å»äº’è¸¢åŠŸèƒ½,å­˜åœ¨å®‰å…¨é£é™©

---

## 8. æœ€ä½³å®è·µæ€»ç»“

1. âœ… **Redis Key è®¾è®¡**: ä½¿ç”¨åˆ†å±‚å‘½å,ç»Ÿä¸€å‰ç¼€,æ–¹ä¾¿ç®¡ç†ã€‚
2. âœ… **Pipeline ä¼˜åŒ–**: æ‰¹é‡æ“ä½œå‡å°‘ç½‘ç»œå¾€è¿”,æå‡æ€§èƒ½ã€‚
3. âœ… **TTL è‡ªåŠ¨è¿‡æœŸ**: åˆ©ç”¨ Redis TTL è‡ªåŠ¨æ¸…ç†è¿‡æœŸ Key,æ— éœ€æ‰‹åŠ¨ç»´æŠ¤ã€‚
4. âœ… **åŒé‡æ ¡éªŒ**: JWT ç­¾å + Redis çŠ¶æ€,å®‰å…¨æ€§æ›´é«˜ã€‚
5. âœ… **é™çº§æ–¹æ¡ˆ**: Redis æ•…éšœæ—¶,å¯é™çº§ä¸ºçº¯ JWT æ¨¡å¼(å¯é€‰)ã€‚
6. âœ… **æ—¥å¿—è®°å½•**: è®°å½•äº’è¸¢äº‹ä»¶,æ–¹ä¾¿æ’æŸ¥å¼‚å¸¸ç™»å½•ã€‚

---

## 9. è¯¾åç»ƒä¹ 

### ç»ƒä¹  1: å®ç°è®¾å¤‡ç®¡ç†æ¥å£

**éœ€æ±‚:** ç”¨æˆ·å¯ä»¥æŸ¥çœ‹æ‰€æœ‰ç™»å½•è®¾å¤‡,å¹¶è¸¢æ‰æŒ‡å®šè®¾å¤‡ã€‚

**æ¥å£è®¾è®¡:**

```go
// æŸ¥çœ‹æˆ‘çš„è®¾å¤‡
GET /api/v1/my_devices

Response:
{
  "devices": [
    {
      "device_id": "abc123",
      "device_name": "iPhone 13",
      "last_active": "2025-01-10 10:30:00",
      "is_current": true
    },
    {
      "device_id": "def456",
      "device_name": "Chrome on Windows",
      "last_active": "2025-01-09 15:20:00",
      "is_current": false
    }
  ]
}

// è¸¢æ‰æŒ‡å®šè®¾å¤‡
POST /api/v1/kick_device
{
  "device_id": "def456"
}
```

### ç»ƒä¹  2: å®ç°"è®°ä½è®¾å¤‡"åŠŸèƒ½

**éœ€æ±‚:** ç”¨æˆ·å¯ä»¥é€‰æ‹©"è®°ä½æ­¤è®¾å¤‡",è¯¥è®¾å¤‡ç™»å½•æ—¶ä¸ä¼šè¸¢æ‰å…¶ä»–è®¾å¤‡ã€‚

**æç¤º:** ä¸º"è®°ä½çš„è®¾å¤‡"ä½¿ç”¨ç‰¹æ®Šçš„ Redis Key,åœ¨ä¸­é—´ä»¶ä¸­ç‰¹æ®Šå¤„ç†ã€‚

### ç»ƒä¹  3: å®ç°åœ¨çº¿çŠ¶æ€ç›‘æ§

**éœ€æ±‚:** ç®¡ç†å‘˜å¯ä»¥æŸ¥çœ‹å½“å‰åœ¨çº¿ç”¨æˆ·æ•°ã€‚

**æç¤º:** åˆ©ç”¨ Redis `KEYS` å‘½ä»¤ç»Ÿè®¡ `bluebell:user:access_token:*` çš„æ•°é‡ã€‚

---

## 10. å»¶ä¼¸é˜…è¯»

- ğŸ“– [Redis Pipeline æ–‡æ¡£](https://redis.io/topics/pipelining)
- ğŸ“– [Redis Key è®¾è®¡æœ€ä½³å®è·µ](https://redis.io/topics/data-types-intro)
- ğŸ“– ä¸‹ä¸€ç« : [ç¬¬11ç« :é›†æˆSwaggerè‡ªåŠ¨ç”Ÿæˆæ–‡æ¡£](./11-é›†æˆSwaggerè‡ªåŠ¨ç”Ÿæˆæ–‡æ¡£.md)
