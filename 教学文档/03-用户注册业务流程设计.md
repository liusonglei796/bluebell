# 第03章: 用户注册业务流程设计

> **学习目标**: 掌握三层架构(CLD)的设计思想,理解注册业务的完整流程,学会职责分离的编程范式。

---

## 📚 本章导读

现在我们已经有了:
- ✅ 用户表结构设计 (第01章)
- ✅ Snowflake ID 生成器 (第02章)

本章将把这些组件串联起来,完成**用户注册**这个核心业务功能。

我们将学习:
1. 什么是三层架构(Controller-Logic-DAO)
2. 注册业务的完整流程设计
3. 如何将需求拆解到不同的层级
4. 如何设计清晰的函数签名和错误处理

---

## 1. 三层架构(CLD)设计模式

### 1.1 为什么需要分层?

**反面教材:** 所有逻辑写在一个函数里

```go
// ❌ 糟糕的设计
func SignUpHandler(c *gin.Context) {
    // 1. 获取参数
    var p ParamSignUp
    c.ShouldBindJSON(&p)

    // 2. 参数校验
    if len(p.Username) < 3 { ... }

    // 3. 查询数据库
    db.QueryRow("SELECT * FROM user WHERE username=?", p.Username)

    // 4. 生成ID
    userID := snowflake.GenID()

    // 5. 密码加密
    hashedPwd, _ := bcrypt.GenerateFromPassword(...)

    // 6. 插入数据库
    db.Exec("INSERT INTO user ...", userID, p.Username, hashedPwd)

    // 7. 返回响应
    c.JSON(200, gin.H{"msg": "ok"})
}
```

**问题:**
- ❌ 函数过长,难以阅读
- ❌ 职责不清,难以测试
- ❌ 代码重复,难以复用
- ❌ 修改困难,容易出错

### 1.2 三层架构的设计

```
┌─────────────────────────────────────────────────────┐
│                    HTTP 请求                         │
│                       ↓                              │
│  ┌────────────────────────────────────────────┐    │
│  │  Controller 层 (控制层 - 交通警察)         │    │
│  │  职责: 参数解析、校验、调用业务、返回响应   │    │
│  └────────────────────────────────────────────┘    │
│                       ↓                              │
│  ┌────────────────────────────────────────────┐    │
│  │  Logic 层 (业务逻辑层 - 大脑)              │    │
│  │  职责: 编排业务流程、调用数据访问层        │    │
│  └────────────────────────────────────────────┘    │
│                       ↓                              │
│  ┌────────────────────────────────────────────┐    │
│  │  DAO 层 (数据访问层 - 仓库管理员)          │    │
│  │  职责: 执行SQL、操作Redis、返回数据        │    │
│  └────────────────────────────────────────────┘    │
│                       ↓                              │
│               Database (MySQL/Redis)                │
└─────────────────────────────────────────────────────┘
```

### 1.3 各层职责详解

#### Controller 层 (控制器)

**职责:** "交通警察"

```go
func SignUpHandler(c *gin.Context) {
    // 1. 获取并校验参数
    var p models.ParamSignUp
    if err := c.ShouldBindJSON(&p); err != nil {
        ResponseError(c, CodeInvalidParam)
        return
    }

    // 2. 调用业务逻辑
    if err := logic.SignUp(&p); err != nil {
        ResponseError(c, CodeServerBusy)
        return
    }

    // 3. 返回成功响应
    ResponseSuccess(c, nil)
}
```

**核心原则:**
- ✅ 只做参数处理和响应
- ✅ 不包含业务逻辑
- ✅ 不直接操作数据库
- ✅ 统一错误处理

#### Logic 层 (业务逻辑)

**职责:** "大脑" - 编排业务流程

```go
func SignUp(p *models.ParamSignUp) error {
    // 1. 检查用户是否存在
    if err := mysql.CheckUserExist(p.Username); err != nil {
        return err
    }

    // 2. 生成用户ID
    userID := snowflake.GenID()

    // 3. 密码加密
    hashedPwd, _ := bcrypt.GenerateFromPassword(...)

    // 4. 保存用户
    user := &models.User{
        UserID: userID,
        Username: p.Username,
        Password: string(hashedPwd),
    }
    return mysql.InsertUser(user)
}
```

**核心原则:**
- ✅ 实现核心业务逻辑
- ✅ 编排多个操作步骤
- ✅ 调用 DAO 层获取数据
- ✅ 返回明确的错误信息

#### DAO 层 (数据访问)

**职责:** "仓库管理员" - 执行数据操作

```go
// 检查用户是否存在
func CheckUserExist(username string) error {
    sqlStr := "SELECT id FROM user WHERE username = ?"
    var id int64
    if err := db.Get(&id, sqlStr, username); err != nil {
        if err == sql.ErrNoRows {
            return nil // 用户不存在,返回 nil
        }
        return err
    }
    return ErrorUserExist // 用户已存在
}

// 插入用户
func InsertUser(user *models.User) error {
    sqlStr := `INSERT INTO user(user_id, username, password)
               VALUES (?, ?, ?)`
    _, err := db.Exec(sqlStr, user.UserID, user.Username, user.Password)
    return err
}
```

**核心原则:**
- ✅ 只负责数据库/Redis 操作
- ✅ 提供原子化的数据操作
- ✅ 不包含业务逻辑
- ✅ 返回明确的错误类型

---

## 2. 注册业务完整流程

### 2.1 流程图

```
用户提交注册表单
    ↓
┌──────────────────────────────────┐
│  Controller: SignUpHandler       │
│  1. 解析 JSON 参数                │
│  2. 参数校验(validator)           │
└──────────────────────────────────┘
    ↓
┌──────────────────────────────────┐
│  Logic: SignUp                   │
│  1. 检查用户名是否已存在          │
│  2. 生成用户ID(Snowflake)        │
│  3. 密码加密(bcrypt)             │
│  4. 保存用户到数据库              │
└──────────────────────────────────┘
    ↓
┌──────────────────────────────────┐
│  DAO: MySQL                      │
│  1. CheckUserExist               │
│  2. InsertUser                   │
└──────────────────────────────────┘
    ↓
    返回成功/失败响应
```

### 2.2 数据流转

```go
// 1. 用户输入 (前端)
{
    "username": "alice",
    "password": "123456",
    "re_password": "123456"
}

// 2. Controller 接收 (gin.Context)
var p models.ParamSignUp
c.ShouldBindJSON(&p)

// 3. Logic 处理
userID := snowflake.GenID()  // 256294141623799808
hashedPwd := bcrypt.Hash(p.Password)  // $2a$10$...

// 4. DAO 存储
INSERT INTO user VALUES (256294141623799808, 'alice', '$2a$10$...')

// 5. 返回响应
{
    "code": 1000,
    "msg": "success"
}
```

---

## 3. 代码实现

### 3.1 定义参数模型

#### 文件: `models/params.go`

```go
package models

// ParamSignUp 注册请求参数
type ParamSignUp struct {
	// binding 标签用于参数校验
	Username   string `json:"username" binding:"required"`
	Password   string `json:"password" binding:"required"`
	RePassword string `json:"re_password" binding:"required,eqfield=Password"`
}
```

**binding 标签说明:**

| 标签 | 含义 | 示例 |
|------|------|------|
| `required` | 必填字段 | `binding:"required"` |
| `eqfield` | 等于某个字段 | `binding:"eqfield=Password"` |
| `min` | 最小长度 | `binding:"min=6"` |
| `max` | 最大长度 | `binding:"max=20"` |

详细内容见 [第04章: 请求参数绑定与校验](./04-请求参数绑定与校验.md)

### 3.2 Controller 层实现

#### 文件: `controller/user.go`

```go
package controller

import (
	"bluebell/logic"
	"bluebell/models"

	"github.com/gin-gonic/gin"
	"go.uber.org/zap"
)

// SignUpHandler 处理用户注册请求
func SignUpHandler(c *gin.Context) {
	// 1. 获取参数并校验
	var p models.ParamSignUp
	if err := c.ShouldBindJSON(&p); err != nil {
		// 参数校验失败
		zap.L().Error("SignUp with invalid param", zap.Error(err))
		ResponseError(c, CodeInvalidParam)
		return
	}

	// 2. 业务处理
	if err := logic.SignUp(&p); err != nil {
		// 业务处理失败
		zap.L().Error("logic.SignUp failed", zap.Error(err))
		// 根据错误类型返回不同的错误码
		if err == logic.ErrorUserExist {
			ResponseError(c, CodeUserExist)
			return
		}
		ResponseError(c, CodeServerBusy)
		return
	}

	// 3. 返回成功响应
	ResponseSuccess(c, nil)
}
```

**关键点解析:**

1. **参数绑定与校验**
```go
if err := c.ShouldBindJSON(&p); err != nil {
    // Gin 的 validator 会自动校验 binding 标签
    // 如果校验失败,err 会包含详细信息
}
```

2. **错误分类处理**
```go
// 根据业务错误类型,返回不同的错误码
if err == logic.ErrorUserExist {
    ResponseError(c, CodeUserExist)  // 用户已存在
} else {
    ResponseError(c, CodeServerBusy) // 其他错误
}
```

3. **日志记录**
```go
// 详细的错误信息记录到日志,方便调试
zap.L().Error("logic.SignUp failed", zap.Error(err))

// 用户只看到友好的错误提示
ResponseError(c, CodeServerBusy)
```

### 3.3 Logic 层实现

#### 文件: `logic/user.go`

```go
package logic

import (
	"bluebell/dao/mysql"
	"bluebell/models"
	"bluebell/pkg/snowflake"
	"errors"

	"golang.org/x/crypto/bcrypt"
)

// 定义业务错误
var (
	ErrorUserExist       = errors.New("用户已存在")
	ErrorUserNotExist    = errors.New("用户不存在")
	ErrorInvalidPassword = errors.New("密码错误")
)

// SignUp 用户注册业务逻辑
func SignUp(p *models.ParamSignUp) error {
	// 1. 判断用户是否存在
	if err := mysql.CheckUserExist(p.Username); err != nil {
		// 如果是用户已存在错误,直接返回
		if err == mysql.ErrorUserExist {
			return ErrorUserExist
		}
		// 其他数据库错误
		return err
	}

	// 2. 生成 UID (使用雪花算法)
	userID := snowflake.GenID()

	// 3. 密码加密
	// bcrypt.GenerateFromPassword 会自动加盐并哈希
	hashedPassword, err := bcrypt.GenerateFromPassword(
		[]byte(p.Password),
		bcrypt.DefaultCost, // 默认代价因子(10)
	)
	if err != nil {
		return err
	}

	// 4. 构造用户对象
	user := &models.User{
		UserID:   userID,
		Username: p.Username,
		Password: string(hashedPassword),
	}

	// 5. 保存进数据库
	return mysql.InsertUser(user)
}
```

**业务流程详解:**

**步骤1: 检查用户是否存在**
```go
if err := mysql.CheckUserExist(p.Username); err != nil {
    // 为什么要先检查?
    // - 避免重复用户名
    // - 提供友好的错误提示
    // - 利用数据库的唯一索引作为最后防线
}
```

**步骤2: 生成用户ID**
```go
userID := snowflake.GenID()
// 生成的ID示例: 256294141623799808
// 全局唯一、趋势递增、不可预测
```

**步骤3: 密码加密**
```go
hashedPassword, _ := bcrypt.GenerateFromPassword(
    []byte(p.Password),
    bcrypt.DefaultCost,
)

// 输入: "123456"
// 输出: "$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy"
//       ↑    ↑  ↑─────────────── 盐值 ─────────────────┴─── 哈希值 ───┘
//       │    └─ 代价因子(10)
//       └─ bcrypt 版本
```

详见 [第06章: 用户密码加密与数据持久化](./06-用户密码加密与数据持久化.md)

**步骤4-5: 保存数据**
```go
user := &models.User{
    UserID:   userID,
    Username: p.Username,
    Password: string(hashedPassword),
}
return mysql.InsertUser(user)
```

### 3.4 DAO 层实现

#### 文件: `dao/mysql/user.go`

```go
package mysql

import (
	"bluebell/models"
	"database/sql"
	"errors"
)

// 定义DAO层错误
var (
	ErrorUserExist    = errors.New("用户已存在")
	ErrorUserNotExist = errors.New("用户不存在")
)

// CheckUserExist 检查用户是否存在
func CheckUserExist(username string) error {
	sqlStr := `SELECT id FROM user WHERE username = ?`
	var id int64
	if err := db.Get(&id, sqlStr, username); err != nil {
		// sql.ErrNoRows 表示没有查询到记录
		if err == sql.ErrNoRows {
			return nil // 用户不存在,返回 nil (正常情况)
		}
		return err // 数据库查询错误
	}
	return ErrorUserExist // 查询到记录,说明用户已存在
}

// InsertUser 插入新用户
func InsertUser(user *models.User) error {
	sqlStr := `INSERT INTO user(user_id, username, password)
	           VALUES (?, ?, ?)`
	_, err := db.Exec(sqlStr, user.UserID, user.Username, user.Password)
	return err
}
```

**关键设计:**

1. **明确的错误类型**
```go
// ✅ 定义业务相关的错误
var ErrorUserExist = errors.New("用户已存在")

// Logic 层可以根据错误类型做判断
if err == mysql.ErrorUserExist {
    return logic.ErrorUserExist
}
```

2. **SQL 错误处理**
```go
if err == sql.ErrNoRows {
    // 没有查询到记录,对于"检查用户是否存在"来说是正常的
    return nil
}
```

3. **使用 sqlx 的便捷方法**
```go
// Get: 查询单行数据
db.Get(&id, sqlStr, username)

// Exec: 执行插入/更新/删除
db.Exec(sqlStr, args...)
```

---

## 4. 路由注册

#### 文件: `routers/routers.go`

```go
func SetupRouter(mode string) *gin.Engine {
	r := gin.New()
	r.Use(logger.GinLogger(), logger.GinRecovery(true))

	// 注册公开路由(不需要登录)
	v1 := r.Group("/api/v1")
	{
		v1.POST("/signup", controller.SignUpHandler)  // 注册
		v1.POST("/login", controller.LoginHandler)    // 登录
	}

	return r
}
```

---

## 5. 完整的请求响应流程

### 5.1 成功场景

```bash
# 请求
POST /api/v1/signup HTTP/1.1
Content-Type: application/json

{
    "username": "alice",
    "password": "123456",
    "re_password": "123456"
}

# 响应
HTTP/1.1 200 OK
Content-Type: application/json

{
    "code": 1000,
    "msg": "success",
    "data": null
}
```

**流程追踪:**
```
1. Gin 接收 HTTP 请求
2. 路由匹配到 SignUpHandler
3. Controller 解析并校验参数 ✅
4. 调用 logic.SignUp
5. Logic 检查用户不存在 ✅
6. Logic 生成 ID: 256294141623799808
7. Logic 加密密码: $2a$10$...
8. DAO 插入数据库 ✅
9. Controller 返回成功响应
```

### 5.2 失败场景: 用户已存在

```bash
# 请求
POST /api/v1/signup
{
    "username": "alice",  # 已存在的用户名
    "password": "123456",
    "re_password": "123456"
}

# 响应
{
    "code": 1003,
    "msg": "用户已存在",
    "data": null
}
```

**流程追踪:**
```
1-4. (同上)
5. Logic 检查用户已存在 ❌
6. DAO 返回 mysql.ErrorUserExist
7. Logic 返回 logic.ErrorUserExist
8. Controller 识别错误类型
9. Controller 返回 CodeUserExist 错误码
```

### 5.3 失败场景: 参数错误

```bash
# 请求
{
    "username": "al",  # 太短
    "password": "123456",
    "re_password": "654321"  # 不匹配
}

# 响应
{
    "code": 1002,
    "msg": "请求参数错误",
    "data": null
}
```

**流程追踪:**
```
1-2. (同上)
3. Controller 参数校验失败 ❌
4. 直接返回 CodeInvalidParam
(不会执行 Logic 层)
```

---

## 6. 错误码设计

#### 文件: `controller/code.go`

```go
package controller

type ResCode int64

const (
	CodeSuccess      ResCode = 1000  // 成功
	CodeInvalidParam ResCode = 1002  // 请求参数错误
	CodeUserExist    ResCode = 1003  // 用户已存在
	CodeUserNotExist ResCode = 1004  // 用户不存在
	CodeServerBusy   ResCode = 1005  // 服务繁忙
	// ... 更多错误码
)

var codeMsgMap = map[ResCode]string{
	CodeSuccess:      "success",
	CodeInvalidParam: "请求参数错误",
	CodeUserExist:    "用户已存在",
	CodeUserNotExist: "用户不存在",
	CodeServerBusy:   "服务繁忙",
}
```

详见 [第09章: 标准化API响应与错误码](./09-标准化API响应与错误码.md)

---

## 7. 知识回顾与总结

### 7.1 三层架构总结

```
┌──────────────────────────────────────────────┐
│           职责分离原则                        │
├──────────────────────────────────────────────┤
│  Controller: 我只做交警                       │
│    - 接收请求、校验参数、返回响应              │
│    - 不写业务逻辑                             │
│                                              │
│  Logic: 我是大脑                             │
│    - 编排业务流程                             │
│    - 不直接操作数据库                         │
│                                              │
│  DAO: 我是仓库管理员                          │
│    - 执行SQL                                 │
│    - 不关心业务逻辑                           │
└──────────────────────────────────────────────┘
```

### 7.2 注册流程核心步骤

1. ✅ 参数校验(Controller)
2. ✅ 检查用户是否存在(DAO)
3. ✅ 生成用户ID(Snowflake)
4. ✅ 密码加密(bcrypt)
5. ✅ 保存数据库(DAO)

---

## 8. 课后练习

### 练习1: 实现登录功能

参考注册流程,实现登录功能:

```go
// Controller
func LoginHandler(c *gin.Context)

// Logic
func Login(p *models.ParamLogin) (token string, err error)

// DAO
func GetUserByUsername(username string) (*models.User, error)
```

提示: 使用 `bcrypt.CompareHashAndPassword` 验证密码

### 练习2: 添加邮箱字段

扩展注册功能,支持邮箱注册:

1. 修改 `ParamSignUp` 添加 `email` 字段
2. 添加邮箱格式校验
3. 修改数据库插入逻辑

### 练习3: 重复检查优化

思考:
- 当前的重复检查依赖数据库查询,性能如何?
- 如何使用 Redis 优化重复检查?
- 如何处理并发注册的问题?

---

**下一章:** [第04章: 请求参数绑定与校验](./04-请求参数绑定与校验.md)

**返回目录:** [README.md](./README.md)
